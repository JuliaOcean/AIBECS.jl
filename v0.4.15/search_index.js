var documenterSearchIndex = {"docs":
[{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/tutorials/3_Pmodel.jl\"","category":"page"},{"location":"tutorials/3_Pmodel/#P-model-1","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"","category":"section"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"In this tutorial we will explicitly simulate 2 tracers whose distributions control and feed back on each other.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We consider a simple model for the cycling of phosphorus with 2 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP) and particulate organic phosphorus (POP). The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The governing equations that couple the 3D concentration fields of DIP and POP, denoted x_mathsfDIP and x_mathsfPOP, respectively, are:","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"leftfracpartialpartial t + nabla cdot (boldsymbolu + mathbfKnabla )right x_mathsfDIP = -U(x_mathsfDIP) + R(x_mathsfPOP)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"and","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"leftfracpartialpartial t + nabla cdot boldsymbolwright x_mathsfPOP = U(x_mathsfDIP) - R(x_mathsfPOP)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The nabla cdot left boldsymbolu - mathbfK nabla right and nabla cdot boldsymbolw operators represent the ocean circulation and the sinking of particles, respectively. (Tracer transport operators are described in the documentation.)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The function U represents the biological uptake of DIP by phytoplankton, which we model here as","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"U(x_mathsfDIP) = fracx_mathsfDIPtau_mathsfDIP  fracx_mathsfDIPx_mathsfDIP + k  (z  z_0)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"with the timescale, tau, the half-saturation rate k, and the depth z_0 as parameters.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The function R defines the remineralization rate of POP, which converts POP back into DIP. For the remineralization, we simply use a linear rate constant, i.e.,","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"R(x_mathsfPOP) = fracx_mathsfPOPtau_mathsfPOP","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We start by telling Julia we want to use the AIBECS and the OCIM0.1 circulation for DIP.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"using AIBECS\ngrd, T_OCIM = OCIM0.load()\nT_DIP(p) = T_OCIM","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the sinking of particles, we use the transportoperator function","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"T_POP(p) = transportoperator(grd, w = w(p))","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"for which we need to define the sinking speed w(p) as a function of the parameters p. Following the assumption that w = w_0 + w z increases linearly with depth, we write it as","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function w(p)\n    @unpack w₀, w′ = p\n    return @. w₀ + w′ * z\nend","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For this to work, we must create a vector of depths, z, which is simply done via","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"z = depthvec(grd)","category":"page"},{"location":"tutorials/3_Pmodel/#Uptake-(DIP-POP)-1","page":"A coupled PO₄–POP model","title":"Uptake (DIP → POP)","text":"","category":"section"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the uptake, U, we write","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function U(x,p)\n    @unpack τDIP, k, z₀ = p\n    return @. x/τDIP * x/(x+k) * (z≤z₀) * (x≥0)\nend","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"where we have \"unpacked\" the parameters to make the code clearer and as close to the mathematical equation as possible. (Note we have also added a constraint that x must be positive for uptake to happen.)","category":"page"},{"location":"tutorials/3_Pmodel/#Remineralization-(POP-DIP)-1","page":"A coupled PO₄–POP model","title":"Remineralization (POP → DIP)","text":"","category":"section"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the remineralization, R, we write","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function R(x,p)\n    @unpack τPOP = p\n    return x / τPOP\nend","category":"page"},{"location":"tutorials/3_Pmodel/#Net-sources-and-sinks-1","page":"A coupled PO₄–POP model","title":"Net sources and sinks","text":"","category":"section"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We lump the sources and sinks into G functions for DIP and POP.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function G_DIP(DIP, POP, p)\n    @unpack D̅I̅P̅, τgeo = p\n    return @. -$U(DIP,p) + $R(POP,p) + (D̅I̅P̅ - DIP) / τgeo\nend\nfunction G_POP(DIP, POP, p)\n    return U(DIP,p) - R(POP,p)\nend","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"where we have imposed a slow restoring of DIP to the global mean D̅I̅P̅ to prescribe the global mean concentration. (The $ signs in front of U and R protect them from the broadcast macro @.)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We now define and build the parameters.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"In this tutorial we will specify some initial values for the parameters and also include units.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"import AIBECS: @units, units\nimport AIBECS: @initial_value, initial_value\n@units @initial_value struct PmodelParameters{U} <: AbstractParameters{U}\n    w₀::U   |  0.64 | u\"m/d\"\n    w′::U   |  0.13 | u\"m/d/m\"\n    τDIP::U | 230.0 | u\"d\"\n    k::U    |  6.62 | u\"μmol/m^3\"\n    z₀::U   |  80.0 | u\"m\"\n    τPOP::U |   5.0 | u\"d\"\n    τgeo::U |   1.0 | u\"Myr\"\n    D̅I̅P̅::U  |  2.12 | u\"mmol/m^3\"\nend","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Finally, thanks to the initial values we provided, we can instantiate the parameter vector succintly as","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"p = PmodelParameters()","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We generate the state function F and its Jacobian ∇ₓF,","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"nb = sum(iswet(grd))\nF, ∇ₓF = state_function_and_Jacobian((T_DIP, T_POP), (G_DIP, G_POP), nb)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"generate the steady-state problem,","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"@unpack D̅I̅P̅ = p\nx = D̅I̅P̅ * ones(2nb) # initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"and solve it","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"s = solve(prob, CTKAlg()).u","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We can look at different the DIP and POP fields using the Plots.jl recipes.","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"DIP, POP = state_to_tracers(s, grd) # unpack tracers","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We can plot the concentration of DIP at a given depth via, e.g.,","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"using Plots\nhorizontalslice(DIP * u\"mol/m^3\" .|> u\"μM\", grd, depth=1000u\"m\", color=:viridis)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Or have a look at a map of the uptake at the surface","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"verticalintegral(U(DIP,p) * u\"mol/m^3/s\" .|> u\"mmol/yr/m^3\", grd, color=:algae)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Or look at what is exported below 500 m","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"horizontalslice(POP .* w(p) * u\"mol/m^3*m/s\" .|> u\"mmol/yr/m^2\", grd, depth=500u\"m\", color=:inferno_r)","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"","category":"page"},{"location":"tutorials/3_Pmodel/#","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/howtos/1_parameters.jl\"","category":"page"},{"location":"howtos/1_parameters/#[Parameters-guide](@ref-parameters)-1","page":"Parameters guide","title":"Parameters guide","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Here we will describe the AIBECS interface. This guide will take you through some examples of setting up model parameters.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"note: Note\nThe parameters features in AIBECS essentially come from other packages. These include Parameters.jl, FieldMetadata.jl, Flatten.jl, Unitful.jl.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"As usual, make sure you are using AIBECS","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"using AIBECS","category":"page"},{"location":"howtos/1_parameters/#Abstract-parameters-type-1","page":"Parameters guide","title":"Abstract parameters type","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"The AIBECS provides a set of features to create and use parameters. This features are implemented as functions that must be provided with a parameters type. But each set of parameters is different, and AIBECS cannot know beforehand what parameters you want to use. The AIBECS thus provides an abstract parameters type, called AbstractParameters, upon which all the AIBECS functionality is built. This is why when you create a set of parameters in AIBECS, you must declare it as a subtype of AbstractParameters. Here is an example.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"struct SimpleParams{T} <: AbstractParameters{T}\n    α::T\n    β::T\nend","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Once the type, which here simply defines the symbols (α and β), is constructed, we can instantiate a parameter variable.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = SimpleParams(1.0, 2.0)","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"As you can see, the AIBECS will display p as a table. This is because the show method converts p to a table (a DataFrame to be specific) under the hood:","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"AIBECS.table(p)","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"If you do not remember the order in which you created the parameters (α is first, β is second), AIBECS has got your back: keyword arguments are supported.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = SimpleParams(β = 2.0, α = 1.0)","category":"page"},{"location":"howtos/1_parameters/#Unpacking-1","page":"Parameters guide","title":"Unpacking","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Probably the most useful feature in AIBECS is the ability to elegantly unpack parameters, thanks to Parameters.jl.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"@unpack α, β = p\nα, β","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"unpacks the parameters on the left (α and β) from the parameter type p.","category":"page"},{"location":"howtos/1_parameters/#Units-1","page":"Parameters guide","title":"Units","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"One of the main features of parameters in AIBECS is that you can use units and let AIBECS do the conversions for you. Before you use units, though, you must import the @units and units functions from AIBECS. Here is an example.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @units, units\n@units struct UnitfulParams{T} <: AbstractParameters{T}\n    α::T | u\"m/s\"\n    β::T | u\"d\"\nend","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Cretaing an instance is just as easy","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(1.0, 2.0)","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"And in this case the parameters are shown with units. You can rely on AIBECS to convert units on the fly.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(3.0u\"km/hr\", 24.0u\"hr\")","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"And use keyword arguments","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(β = 24.0u\"hr\", α = 3.0u\"km/hr\")","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Unpacking parameters that have units first converts them to SI units.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"@unpack β = p\nβ","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"and β (which is equal to 1 day) here is expressed in seconds after being unpacked.","category":"page"},{"location":"howtos/1_parameters/#Initial-values-1","page":"Parameters guide","title":"Initial values","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Another useful feature is to set initial (or default) values. Again, you must import the functions for them to work properly","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @initial_value, initial_value\n@initial_value struct ParamsWithInitialValue{T} <: AbstractParameters{T}\n    α::T | 1.0\n    β::T | 2.0\nend","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"This is handy in many applications.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"You can instantiate p with the initial values as, well, its values.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = ParamsWithInitialValue()","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"You could also just set one parameter to a different value","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = ParamsWithInitialValue(β = 10.0)","category":"page"},{"location":"howtos/1_parameters/#Combining-initial-values-and-units-1","page":"Parameters guide","title":"Combining initial values and units","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"You can combine both features in parameters.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"@units @initial_value struct UnitfulParamsWithInitialValue{T} <: AbstractParameters{T}\n    α::T | 1.0 | u\"m/s\"\n    β::T | 2.0 | u\"d\"\nend","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"And instantiate p from just one parameter with its unit","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParamsWithInitialValue(β = 1.0u\"yr\")","category":"page"},{"location":"howtos/1_parameters/#Optimizable-parameters-1","page":"Parameters guide","title":"Optimizable parameters","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @flattenable, flattenable\n@flattenable struct OptimizableParams{T} <: AbstractParameters{T}\n    α::T | true\n    β::T | false\n    γ::T | true\nend","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Then the \"flattenable\" parameters will be the only ones to remain when converting OptimizableParams to a vector","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"p = OptimizableParams(1.0, 2.0, 3.0)\nv = vec(p)","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"The vec function uses the @unpack function in AIBECS, so that units are converted when vectorizing. Here is an example of that by first combining units and flattenable.","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"@flattenable @units @initial_value struct OptimizableParamsWithUnits{T} <: AbstractParameters{T}\n    α::T | 1.0 | u\"m/s\" | true\n    β::T | 2.0 | u\"d\"   | false\n    γ::T | 3.0 | u\"km\"  | true\nend\np = OptimizableParamsWithUnits()","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"And then vectorizing the parameters","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"vec(p)","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Note how γ (the third parameter, but the second flattenable one), is converted to meters.","category":"page"},{"location":"howtos/1_parameters/#Other-features-1","page":"Parameters guide","title":"Other features","text":"","category":"section"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"Coming soon!","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"","category":"page"},{"location":"howtos/1_parameters/#","page":"Parameters guide","title":"Parameters guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/howtos/3_cruiseplot.jl\"","category":"page"},{"location":"howtos/3_cruiseplot/#cruiseplots-1","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This guide follows the basic plotting guide and its goal is to plot data related to oceanographic observations from cruise expeditions. In this walkthrough, we will 1. Create a ficitious cruise track with profile data 2. Plot transects 3. Other plots","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"As in the basic plotting guide, throughout this guide we will use the OCIM2 grid and we will create a dummy modelled tracer.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using AIBECS, Plots\ngrd, _ = OCIM2.load()\nfdummy(lat, lon, depth) = @. cosd(lat) * sind(lon) + sqrt(depth) / 30\ndummy = fdummy(latlondepthvecs(grd)...)","category":"page"},{"location":"howtos/3_cruiseplot/#fictitiouscruise-1","page":"Plot transect/cruise data","title":"A fictitious cruise","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"For cruise data we use the OceanographyCruises.jl package.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"note: Note\nThe purpose of the OceanographyCruises.jl package is to provide a Julia interface for handling discrete data from cruises. One goal is to use it for, e.g., GEOTRACES data. However here we merely use it to create fictitious cruise data.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Let us create a station Sydney at (34°S, 152°E) and a ALOHA station at (22.75°N, 158°W).","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using OceanographyCruises\nSydney = Station(name=\"Sydney\", lat=-30, lon=156)\nALOHA = Station(name=\"ALOHA\", lat=22.75, lon=-158)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Now let's create a range of 10 stations from Sydney to ALOHA.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Nstations = 10\nstations = range(Sydney, ALOHA, length=Nstations, westmostlon=0)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"(westmostlon=0 ensures that the longitudes are in (0,360) to match the OCIM2 grid we use here.)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"We can now construct a fictitious cruise track","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"ct = CruiseTrack(name=\"CruisyMcCruiseFace\", stations=stations)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"and check the station locations by overlaying a plot of the cruise's track over a surface map of the dummy tracer","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"surfacemap(dummy, grd, color=:grays)\nplotcruisetrack!(ct, markercolor=:red)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Let's create a transect of data that is almost equal to the dummy.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"First, a function for creating random depths","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"function randomdepths(n, max)\n    depths = cumsum(rand(n+1))\n    return max * view(depths,1:n) / maximum(depths)\nend\nNobs = rand(1:20, Nstations) # number of obs per station/profile\ndepths = [randomdepths(Nobs[i], 4000) for i in 1:Nstations]\nobs = [[fdummy(st.lat, st.lon, d) .+ 0.1randn() for d in depths[i]] for (i,st) in enumerate(stations)]\nprofiles = [DepthProfile(station=st, depths=depths[i], values=obs[i]) for (i,st) in enumerate(stations)]\n\nt = Transect(tracer=\"dummy\", cruise=ct.name, profiles=profiles)","category":"page"},{"location":"howtos/3_cruiseplot/#transects-1","page":"Plot transect/cruise data","title":"Transects","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#Zonal-transect-1","page":"Plot transect/cruise data","title":"Zonal transect","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"We can plot the modelled dummy data along the ct cruise track in the zonal directiion (along longitudes) with","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"zonaltransect(dummy, grd, ct=ct)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"If we want the observations transect on top of it","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"zonalscattertransect!(t)","category":"page"},{"location":"howtos/3_cruiseplot/#Meridional-transect-1","page":"Plot transect/cruise data","title":"Meridional transect","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Same for meridional transects (along latitude)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"meridionaltransect(dummy, grd, ct=ct)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"and","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"meridionalscattertransect!(t)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"If you have the GEOTRACESTools package installed and the GEOTRACES data installed at the right location, you can instead plot real data with something like","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using GEOTRACESTools\nzonalscattertransect(tracertransect(\"Fe\", \"GA02\"))","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"However, this cannot be showcased online because GEOTRACES decided its data should \"not be distributed to third parties\".","category":"page"},{"location":"howtos/3_cruiseplot/#other-plots-1","page":"Plot transect/cruise data","title":"Other plots","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Plots the modelled ratio of two modelled tracers at a given station.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"dummy1 = cosd.(latvec(grd)) + sqrt.(depthvec(grd)) / 30\ndummy2 = cosd.(2latvec(grd)) + 0.5sqrt.(depthvec(grd)) / 30\nratioatstation(dummy1, dummy2, grd, ALOHA, xlabel=\"dummy 1\", ylabel=\"dummy 2\")","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This can be useful to compare stoichiometric ratios at different stations.","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"ratioatstation!(dummy1, dummy2, grd, Sydney, marker=:square)","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"","category":"page"},{"location":"howtos/3_cruiseplot/#","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/howtos/2_plot.jl\"","category":"page"},{"location":"howtos/2_plot/#plots-1","page":"Plot basic things","title":"Plot basic things","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"This guide is organized as follows","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"Horizontal maps\nVertical slices\nDepth profiles","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"In this guide we will focus on how-to plot things using AIBECS' built-in recipes for Plots.jl. These recipes are implemented using RecipesBase.jl, which are explained in Plots.jl's documentation.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"Throughout we will use the OCIM2 grid and we will create a dummy tracer as a function of location to showcase each plot, just for the sake of the examples herein.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"using AIBECS, Plots\ngrd, _ = OCIM2.load()\ndummy = cosd.(latvec(grd))","category":"page"},{"location":"howtos/2_plot/#horizontal-plots-1","page":"Plot basic things","title":"Horizontal plots","text":"","category":"section"},{"location":"howtos/2_plot/#Horizontal-slice-1","page":"Plot basic things","title":"Horizontal slice","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"The most common thing you plot after a simulation of marine tracers is a horizontal slice. In this case, you just need to provide the tracer (dummy here), the grid object grd, and the depth at which you want to plot.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"horizontalslice(dummy, grd, depth=10)","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"You can supply units for the depth at which you want to see the horizontal slice.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"horizontalslice(dummy, grd, depth=10u\"m\")","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"And the units should be understood under the hood.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"horizontalslice(dummy, grd, depth=3u\"km\")","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"If your tracer is supplied with units, those will show in the colorbar label","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"horizontalslice(dummy * u\"mol/m^3\", grd, depth=10u\"m\")","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"The advantage of Plots.jl recipes like this one is that you can specify other pieces of the plot as you would with built-in functions. The advantage of Plots.jl recipes like this one is that you can specify other pieces of the plot as you would with built-in functions. For example, you can chose the colormap with the color keyword argument.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"dummy .*= cosd.(lonvec(grd))\nplt = horizontalslice(dummy, grd, depth=100, color=:balance)","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"And you can finetune attributes after the plot is created.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"plot!(plt, xlabel=\"Lon\", ylabel=\"Lat\", colorbar_title=\"dummy value\", title=\"The pacific as a whole\")","category":"page"},{"location":"howtos/2_plot/#vertical-plots-1","page":"Plot basic things","title":"Vertical plots","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"Exploring the vertical distribution of tracers is important after all.","category":"page"},{"location":"howtos/2_plot/#Zonal-slices-1","page":"Plot basic things","title":"Zonal slices","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"You must specify the longitude","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"dummy .= cosd.(latvec(grd))\ndummy .+= sqrt.(depthvec(grd)) / 30\nmeridionalslice(dummy, grd, lon=330)","category":"page"},{"location":"howtos/2_plot/#Zonal-averages-1","page":"Plot basic things","title":"Zonal averages","text":"","category":"section"},{"location":"howtos/2_plot/#Global-zonal-average-1","page":"Plot basic things","title":"Global zonal average","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"zonalaverage(dummy, grd)","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"If you want a zonal average over a specific region, you can just mask it out","category":"page"},{"location":"howtos/2_plot/#Basin-zonal-average-1","page":"Plot basic things","title":"Basin zonal average","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"This is experimental at this stage and relies on an unregistered package OceanBasins. This part of the documentation will be online when OceanBasins gets registered.","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"You can create basin masks using this package with","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"using OceanBasins\nmPAC = ispacific(grd)[iwet]\nsurfacemap(mPAC, grd, seriestype=:heatmap, color=:lightrainbow)\nzonalaverage(dummy, grd, mask=mPAC)","category":"page"},{"location":"howtos/2_plot/#Meridional-slices-1","page":"Plot basic things","title":"Meridional slices","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"Just as you should expect at this stage, you can plot a meridional slice with","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"zonalslice(dummy, grd, lat=-30)","category":"page"},{"location":"howtos/2_plot/#profile-plots-1","page":"Plot basic things","title":"Depth profiles","text":"","category":"section"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"Sometimes you want a profile at a given station or location","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"depthprofile(dummy, grd, lonlat=(-30,30))","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"","category":"page"},{"location":"howtos/2_plot/#","page":"Plot basic things","title":"Plot basic things","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#tracer-transport-operators-1","page":"Tracer transport","title":"Tracer transport","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#Transport-operator-1","page":"Tracer transport","title":"Transport operator","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"To model marine biogeochemical tracers on a global scale we need to be able to account for their movement within the 3D ocean. We do this with tracer transport operators, generically denoted by mathcalT. These operators act on a tracer field to give its divergence. In other words, take a tracer with concentration x(boldsymbolr) at location boldsymbolr that is transported by some mechanism represented by the operator mathcalT. Its divergence at boldsymbolr is then (mathcalT x)(boldsymbolr).","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"In the case of the ocean circulation, i.e., the currents and eddies that transport marine tracers floating around in sea water, the transport operator can be represented by","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"mathcalT = nabla cdot left boldsymbolu(boldsymbolr) - mathbfK(boldsymbolr) nabla right","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"The boldsymbolu(boldsymbolr) term represents the mean marine current velocity at location boldsymbolr. Thus, boldsymbolu(boldsymbolr) is a 3D vector aligned with the ocean currents and whose amplitude, in m/s, gives the velocity of the moving sea water. The mathbfK(boldsymbolr) term is a 3×3 matrix that represents eddy diffusivity. That is, it reproduces the effective mixing effect of unresolved eddies, the turbulent vortices that are too small relative to the model grid to be explicitly captured. In earlier models of the ocean circulation, like OCIM's ancestor (denoted OCIM0 in AIBECS), mathbfK was diagonal. Since OCIM1, mathbfK contains non-diagonal to orient mixing preferentially along isopycnals.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"In the case of sinking particles, one can assume that they are only transported downwards with some terminal settling velocity boldsymbolw(boldsymbolr) The corresponding transport operator is then simply","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"mathcalT = nabla cdot boldsymbolw(boldsymbolr)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Discretization-1","page":"Tracer transport","title":"Discretization","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"In order to represent a marine tracer on a computer one needs to discretize the 3D ocean into a discrete grid, i.e., a grid with a finite number of boxes. One can go a long way towards understanding what a tracer transport operator is by playing with a simple model with only a few boxes, which is the goal of this piece of documentation.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"The simple box model we consider is embedded in a 2×2×2 \"shoebox\". It has 5 wet boxes and 3 dry boxes, as illustrated below:","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"<img src=\"https://user-images.githubusercontent.com/4486578/58314610-3b130b80-7e53-11e9-9fe8-9527cdcca2d0.png\" width =800>","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"An example of discretized advection, boldsymbolu, is shown on the image above, and consists of","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"a meridional overturning circulation flowing in a cycle through boxes 1 → 2 → 6 → 5 → 1 (shown in the meridional section 1 panel)\na zonal current in a reentrant cycling through boxes 1 → 3 → 1 (shown in the layer 1 panel)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"note: Note\nThis circulation is available as the Primeau_2x2x2 model. You can load it in AIBECS viagrd, T = Primeau_2x2x2.load()Note that this circulation also contains vertical mixing representing deep convection between boxes 2 ↔ 6 (not shown on the image)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Vectorization-1","page":"Tracer transport","title":"Vectorization","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"In AIBECS, tracers are represented by column vectors. That is, the 3D tracer field, x(boldsymbolr), is vectorized, in the sense that the concentrations in each box are rearranged into a column vector.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"<img src=\"https://user-images.githubusercontent.com/4486578/61757212-fe3ba480-ae02-11e9-8d17-d72866eaafb5.gif\" width =800>","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"The continuous transport operator mathcalT can then be represented by a matrix, denoted by mathbfT, and sometimes called the transport matrix. It turns out that in most cases, this matrix is sparse.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"note: Note\nA sparse matrix behaves the same way as a regular matrix. The only difference is that in a sparse matrix the majority of the entries are zeros. These zeros are not stored explicitly to save computer memory making it possible to deal with fairly high resolution ocean models.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"Mathematically, the discretization and vectorization convert an expression with partial derivatives into a matrix vector product. In summary, for the ocean circulation, we do the following conversion","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"(mathcalT x)(boldsymbolr) = nabla cdot left boldsymbolu(boldsymbolr) - mathbfK(boldsymbolr) nabla right x(boldsymbolr) longrightarrow mathbfT  boldsymbolx","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Ocean-circulations-in-AIBECS-1","page":"Tracer transport","title":"Ocean circulations in AIBECS","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"In AIBECS, there are currently a few available circulations that you can directly load with the AIBECS:","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"Primeau_2x2x2, the circulation described in this documentation page\nTwoBoxModel, the 2-box model of the Sarmiento and Gruber (2006) book\nArcher_etal_2000, the 3-box model of Archer et al. (2000) (also used in the Sarmiento and Gruber (2006) book)\nOCIM0, the unnamed precursor of the OCIM1 (and which should actually be named OCIM0.1)\nOCIM1\nOCIM2","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"To load any of these, you just need to do","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"grd, T = Circulation.load()","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"where Circulation is one of the circulations listed above.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"If you are adventurous, you can create your own circulations. AIBECS provides some tools for this. (This is how the Primeau_2x2x2 and Archer_etal_2000 circulations were created.)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Sinking-particles-in-AIBECS-1","page":"Tracer transport","title":"Sinking particles in AIBECS","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"There are no loadable transport operators for sinking particles, because there are too many ways to represent sinking particles. However, the AIBECS provides tools to create your own transport operators by providing a scalar or a vector of the downward settling velocities, w. For example, you can create the transport operator for particles sinking at 100 m/d everywhere simply via","category":"page"},{"location":"explanation/2_tracer_transport_operators/#","page":"Tracer transport","title":"Tracer transport","text":"T = transportoperator(grd, w=100u\"m/d\")","category":"page"},{"location":"explanation/1_concept/#concept-1","page":"Concept","title":"Concept","text":"","category":"section"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"The AIBECS (pronounced like the cool ibex if you have a french accent) is a new software written in Julia to easily create some marine biogeochemistry models in just a few commands.","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"AIBECS is not just a single model. It's a system that allows you to create a global steady-state biogeochemistry model with just a few simple commands. Basically, you just need to tell AIBECS which ocean circulation to use (from simple toy models of just a few boxes to more complicated global models of the circulation), what elements you want to model/track, and how they are converted into other (the net local sources and sinks of your model). Once the model is set up, chose some parameter values and you can run simulations.","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"AIBECS relies on many tools from linear algebra to run simulations and perform optimizations really fast. AIBECS-generated models are described by a state function, denoted boldsymbolF, which defines how the concentrations of elements in the ocean evolve with time. In mathematical terms, this translates to a system of nonlinear differential equations with the generic form ","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"where boldsymbolx is the state of the model (i.e., the concentrations of the tracers), and boldsymbolp are model parameters. With AIBECS, you can efficiently find the equilibrium of the system (AKA the steady-state). That is when the time-derivative is 0, so that","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"boldsymbolF(boldsymbolx boldsymbolp) = 0","category":"page"},{"location":"explanation/1_concept/#","page":"Concept","title":"Concept","text":"and boldsymbolx does not change with time. Instead of simulating the evolution of boldsymbolx with time and waiting for the system to reach equilibrium — like most biogeochemistry models do — AIBECS uses linear algebra techniques, like Newton's method in multiple dimensions, or Krylov spaces, to implicitly solve for the steady-state solution, hence the \"algebraic\" and \"implicit\" names. This makes AIBECS much faster than the competition!","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/tutorials/2_radiocarbon.jl\"","category":"page"},{"location":"tutorials/2_radiocarbon/#radiocarbon-1","page":"Radiocarbon","title":"Radiocarbon","text":"","category":"section"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"In this tutorial, we will simulate the radiocarbon age using the AIBECS by","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"defining the transport T(p) and the sources and sinks G(x,p),\ndefining the parameters p,\ngenerating the state function F(x,p) and solving the associated steady-state problem,\nand finally making a plot of our simulated radiocarbon age.","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nAlthough this tutorial is self-contained, it involves non-linearitiess and is slightly more complicated than the first tutorial for simulating the ideal age. (So do not hesitate to start with the ideal-age tutorial if you wish.)","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"The tracer equation for radiocarbon is","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"big(partial_t + mathbfT big) boldsymbolR = fraclambdah (overlineboldsymbolR_mathsfatm - boldsymbolR) (boldsymbolz  h) - boldsymbolR  tau","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"where the first term on the right of the equal sign represents the air–sea gas exchange with a piston velocity λ over a depth h and the second term represents the radioactive decay of radiocarbon with timescale tau.","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nWe need not specify the value of the atmospheric radiocarbon concentration because it is not important for determining the age of a water parcel — only the relative concentration boldsymbolRoverlineboldsymbolR_mathsfatm matters.","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"We start by selecting the circulation for Radiocarbon","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"using AIBECS\ngrd, T_OCIM2 = OCIM2.load()\nT(p) = T_OCIM2","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"The local sources and sinks are simply given by","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"function G(R,p)\n    @unpack λ, h, R̅atm, τ = p\n    return @. λ / h * (R̅atm - R) * (z ≤ h) - R / τ\nend","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"We can define z via","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"z = depthvec(grd)","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"In this tutorial we will specify some units for the parameters. Such features must be imported to be used","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"import AIBECS: @units, units","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"We define the parameters using the dedicated API from the AIBECS, including keyword arguments and units this time","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"@units struct RadiocarbonParameters{U} <: AbstractParameters{U}\n    λ::U    | u\"m/yr\"\n    h::U    | u\"m\"\n    τ::U    | u\"yr\"\n    R̅atm::U | u\"M\"\nend","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"For the air–sea gas exchange, we use a constant piston velocity lambda of 50m / 10years. And for the radioactive decay we use a timescale tau of 5730/log(2) years.","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"p = RadiocarbonParameters(λ = 50u\"m\"/10u\"yr\",\n                          h = grd.δdepth[1],\n                          τ = 5730u\"yr\"/log(2),\n                          R̅atm = 42.0u\"nM\")","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nThe parameters are converted to SI units when unpacked. When you specify units for your parameters, you must either supply their values in that unit.","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"We generate the state function and its Jacobian, generate the corresponding steady-state problem, and solve it, via","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"F, ∇ₓF = state_function_and_Jacobian(T, G)\nx = zeros(length(z)) # an initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)\nR = solve(prob, CTKAlg()).u","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"This should take a few seconds on a laptop. Once the radiocarbon concentration is computed, we can convert it into the corresponding age in years, via","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"@unpack τ, R̅atm = p\nC14age = @. log(R̅atm / R) * τ * u\"s\" |> u\"yr\"","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"and plot it at 700 m using the horizontalslice Plots recipe","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"using Plots\nhorizontalslice(C14age, grd, depth=700u\"m\", color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"look at a zonal average using the zonalaverage plot recipe","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"zonalaverage(C14age, grd; color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"or look at a meridional slice through the Atlantic at 30°W using the meridionalslice plot recipe","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"meridionalslice(C14age, grd, lon=-30, color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"","category":"page"},{"location":"tutorials/2_radiocarbon/#","page":"Radiocarbon","title":"Radiocarbon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/4486578/60554111-8fc27400-9d79-11e9-9ca7-6d78ee89ea70.png\" alt=\"logo\" title=\"AIBECS_logo\" align=\"middle\" width=\"50%\"/>","category":"page"},{"location":"#AIBECS.jl-1","page":"Home","title":"AIBECS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Algebraic Implicit Biogeochemistry Elemental Cycling System","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Whatever you do, if you want to use the AIBECS, you must add it to your Julia environment like every Julia package, by typing ]add AIBECS at the REPL.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This documentation is organized in 4 parts[1]:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[1]: following this documentation advice","category":"page"},{"location":"#.-Tutorials-1","page":"Home","title":"1. Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you want to try AIBECS for the first time, this is where you should start.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ideal age tutorial is a good place to start.   It will show you how to generate a simple linear model of an idealized tracer.\nThe radiocarbon tutorial is a little bit more involved,   with some nonlinearities and more advanced use of AIBECS features and syntax\nThe coupled PO₄–POP model tutorial will show you   how to couple 2 interacting tracers,   one for phosphate transported by the ocean circulation,   and one for POP transported by sinking particles.","category":"page"},{"location":"#.-How-to-guides-1","page":"Home","title":"2. How-to guides","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Here you will find goal-oriented walk-through's.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Parameters guide\nPlotting basic things\nPlotting cruise/transects data\nHow to simulate, i.e., solve or timestep your model (coming soon!)\nHow to optimize parameters (coming soon!)\nHow to simulate sinking particles (coming soon!)","category":"page"},{"location":"#.-Explanation/discussion-1","page":"Home","title":"3. Explanation/discussion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Here you will find more general discussions and explanations surrounding the AIBECS.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The concept of the AIBECS\nTracer transport operators","category":"page"},{"location":"#.-Reference-1","page":"Home","title":"4. Reference","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This section contains almost all the functions available in AIBECS.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nThe AIBECS is being developed primarily by Benoît Pasquier with the help of François Primeau and J. Keith Moore from the Department of Earth System Science at the University of California, Irvine, and more recently with the help of Seth John from the Department of Earth Sciences at the University of Southern California.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warn: Warn\nThis package is in active development, so you should expect some bugs to happen.  And if you have any suggestions or feature requests, do not hesitate to start an issue directly on the AIBECS GitHub repository, or even better, a submit a pull request!","category":"page"},{"location":"reference/functions/#AIBECS-functions-1","page":"AIBECS functions","title":"AIBECS functions","text":"","category":"section"},{"location":"reference/functions/#Circulations-1","page":"AIBECS functions","title":"Circulations","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"OCIM1.load\nOCIM0.load\nPrimeau_2x2x2.load\nArcher_etal_2000.load","category":"page"},{"location":"reference/functions/#AIBECS.OCIM1.load","page":"AIBECS functions","title":"AIBECS.OCIM1.load","text":"load\n\nReturns grd and T (in that order) from FigShare repository.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.OCIM0.load","page":"AIBECS functions","title":"AIBECS.OCIM0.load","text":"load\n\nReturns grd and T (in that order) from FigShare repository.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.Primeau_2x2x2.load","page":"AIBECS functions","title":"AIBECS.Primeau_2x2x2.load","text":"load\n\nReturns grd and T (in that order).\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.Archer_etal_2000.load","page":"AIBECS functions","title":"AIBECS.Archer_etal_2000.load","text":"load\n\nReturns grd and T (in that order).\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Plotting-1","page":"AIBECS functions","title":"Plotting","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"interpolateddepthprofile","category":"page"},{"location":"reference/functions/#Others-1","page":"AIBECS functions","title":"Others","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"vector_of_depths\nvector_of_top_depths\nnumber_of_wet_boxes\nindices_of_wet_boxes\narray_of_volumes\nvector_of_volumes\nrearrange_into_3Darray\niswet\ntransportoperator","category":"page"},{"location":"reference/functions/#AIBECS.transportoperator","page":"AIBECS functions","title":"AIBECS.transportoperator","text":"transportoperator(grd; kwargs)\n\nReturns the transportoperator corresponding to the arguments.\n\nExample\n\nCreate the particle flux divergence with settling velocity of 100m/s\n\njulia> T = transportoperator(grd; w=100.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Parameters-1","page":"AIBECS functions","title":"Parameters","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"AbstractParameters\nunpack\nlength(<:AbstractParameters)\nsize(<:AbstractParameters)\nvalues(<:AbstractParameters)\nsymbols\nflattenable_values\nflattenable_symbols\nlatex\ntable\nvec","category":"page"},{"location":"reference/functions/#AIBECS.AbstractParameters","page":"AIBECS functions","title":"AIBECS.AbstractParameters","text":"AbstractParameters{T} <: AbstractVector{T}\n\nAn abstract type for AIBECS model parameters.\n\nParameters in AIBECS use the following convenience packages:\n\nParameters\nFieldMetadata\nFieldDefaults\nFlatten\nUnitful\nDataFrames\nDistributions\n\nThese aim to allow for some nice features, which include\n\nnice syntax for unpacking parameters in functions via the @unpack macro (fron UnPack.jl)\nadditional metadata on parameters\neasy conversion to and from vectors\nuse of units and automatic conversions if necessary\npretty table-format displays\nloading and saving to and from CSV files\nprior estimates for bayesian inference and optimization\n\nSee the list of examples to get an idea of how to generate parameters for your model.\n\nExamples\n\nGenerate a simple parameter type via\n\njulia> struct SimpleParams{T} <: AbstractParameters{T}\n           α::T\n           β::T\n           γ::T\n       end\nSimpleParams\n\nTo create an instance of the SimpleParams(Float64) type, you can do\n\njulia> p = SimpleParams(1.0, 2.0, 3.0)\nSimpleParams{Float64}\n│ Row │ Symbol │ Value   │\n│     │ Symbol │ Float64 │\n├─────┼────────┼─────────┤\n│ 1   │ α      │ 1.0     │\n│ 2   │ β      │ 2.0     │\n│ 3   │ γ      │ 3.0     │\n\nOne of the core features from Parameters is unpacking in functions, e.g.,\n\njulia> function simplef(p)\n           @unpack α, γ = p\n           return α + γ\n       end\nsimplef (generic function with 1 method)\n\njulia> simplef(p) # 1.0 + 3.0\n4.0\n\nMore complex examples are permitted by adding metadata (thanks to FieldMetadata.jl). You can add units\n\njulia> @units struct UnitParams{T} <: AbstractParameters{T}\n           α::T | u\"km\"\n           β::T | u\"hr\"\n           γ::T | u\"m/s\"\n       end ;\n\njulia> p = UnitParams(1.0, 2.0, 3.0)\nUnitParams{Float64}\n│ Row │ Symbol │ Value   │ Unit     │\n│     │ Symbol │ Float64 │ Unitful… │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ α      │ 1.0     │ km       │\n│ 2   │ β      │ 2.0     │ hr       │\n│ 3   │ γ      │ 3.0     │ m s^-1   │\n\nNote that when adding units to your parameters, they will be converted to SI when unpacked, as in, e.g.,\n\njulia> function speed(p)\n           @unpack α, β, γ = p\n           return α / β + γ\n       end\nspeed (generic function with 1 method)\n\njulia> speed(p) # (1.0 km / 2.0 hr + 3 m/s) in m/s\n3.138888888888889\n\nAnother example for optimizable/flattenable parameters\n\njulia> @flattenable @units @initial_value struct OptParams{T} <: AbstractParameters{T}\n           α::T | 3.6 | u\"km\"  | true \n           β::T | 1.0 | u\"hr\"  | false\n           γ::T | 1.0 | u\"m/s\" | true\n       end ;\n\njulia> p = OptParams(initial_value(OptParams)...)\nOptParams{Float64}\n│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Optimizable │\n│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Bool        │\n├─────┼────────┼─────────┼───────────────┼──────────┼─────────────┤\n│ 1   │ α      │ 3.6     │ 3.6           │ km       │ 1           │\n│ 2   │ β      │ 1.0     │ 1.0           │ hr       │ 0           │\n│ 3   │ γ      │ 1.0     │ 1.0           │ m s^-1   │ 1           │\n\nThanks to the FieldMetaData interface, you can chain the following preloaded metadata:\n\ninitial_value\nunits (from Unitful.jl and UnitfulAstro.jl)\nprior (from Distributions.jl)\ndescription (String)\nbounds (2-element Tuple)\nlogscaled (Bool)\nflattenable (to convert to vectors of optimizable parameters only)\nreference (String)\n\nHere is an example of parameter with all the possible metadata available in AIBECS:\n\njulia> @reference @flattenable @logscaled @bounds @description @prior @units @initial_value struct FullParams{T} <: AbstractParameters{T}\n           α::T | 1.0 | u\"km\"  | Normal(0,1)    | \"The distance\"   | (-Inf, Inf) | false | false | \"Jean et al., 2042\" \n           β::T | 2.0 | u\"hr\"  | LogNormal(0,1) | \"The time\"       | (   0, Inf) | true  | true  | \"Claude et al. 1983\" \n           γ::T | 3.0 | u\"mol\" | Normal(1,2)    | \"The # of moles\" | (  -1,   1) | false | true  | \"Dusse et al. 2000\"\n       end ;\n\njulia> FullParams(4.0, 5.0, 6.0)\nFullParams{Float64}\n│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Prior                            │ Description    │ Bounds      │ Logscaled │ Optimizable │ Reference          │\n│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Distribu…                        │ String         │ Tuple…      │ Bool      │ Bool        │ String             │\n├─────┼────────┼─────────┼───────────────┼──────────┼──────────────────────────────────┼────────────────┼─────────────┼───────────┼─────────────┼────────────────────┤\n│ 1   │ α      │ 4.0     │ 1.0           │ km       │ Normal{Float64}(μ=0.0, σ=1.0)    │ The distance   │ (-Inf, Inf) │ 0         │ 0           │ Jean et al., 2042  │\n│ 2   │ β      │ 5.0     │ 2.0           │ hr       │ LogNormal{Float64}(μ=0.0, σ=1.0) │ The time       │ (0, Inf)    │ 1         │ 1           │ Claude et al. 1983 │\n│ 3   │ γ      │ 6.0     │ 3.0           │ mol      │ Normal{Float64}(μ=1.0, σ=2.0)    │ The # of moles │ (-1, 1)     │ 0         │ 1           │ Dusse et al. 2000  │\n\nNote that there is no check that the metadata you give is consistent. These metadata will hopefully be useful for advanced usage of AIBECS, e.g., using prior information and/or bounds for optimization.\n\n\n\n\n\n","category":"type"},{"location":"reference/functions/#AIBECS.latex","page":"AIBECS functions","title":"AIBECS.latex","text":"latex(p)\n\nReturns a LaTeX-formatted table of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Base.vec","page":"AIBECS functions","title":"Base.vec","text":"vec(p::T) where {T <: AbstractParameters}\n\nReturns a SI-unit-converted vector of flattenable values of p.\n\nNote that vec(p) ≠ flattenable_values(p) if p has units.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#For-simulations-1","page":"AIBECS functions","title":"For simulations","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"state_function_and_Jacobian\nsplit_state_function_and_Jacobian\nSteadyStateProblem\nsolve\neuler_forward_step\neuler_forward_step!\ncrank_nicolson_step\ncrank_nicolson_step!\ncrank_nicolson_leapfrog_step\ncrank_nicolson_leapfrog_step_A⁺_and_A⁻\neuler_backward_step \neuler_backward_step!","category":"page"},{"location":"reference/functions/#AIBECS.state_function_and_Jacobian","page":"AIBECS functions","title":"AIBECS.state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.split_state_function_and_Jacobian","page":"AIBECS functions","title":"AIBECS.split_state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#DiffEqBase.SteadyStateProblem","page":"AIBECS functions","title":"DiffEqBase.SteadyStateProblem","text":"SteadyStateProblem(F, ∇ₓF, x, p)\n\nReturns the SteadyStateProblem defined by F(x,p)=0.\n\n\n\n\n\n","category":"type"},{"location":"reference/functions/#DiffEqBase.solve","page":"AIBECS functions","title":"DiffEqBase.solve","text":"solve(prob::DiffEqBase.AbstractSteadyStateProblem,\n      alg::CTKAlg;\n      nrm=norm,\n      τstop=1e12*365*24*60*60,\n      preprint=\"\",\n      maxItNewton=50)\n\nSolves prob using the modified C.T.Kelley Shamanskii algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#For-optimization-1","page":"AIBECS functions","title":"For optimization","text":"","category":"section"},{"location":"reference/functions/#","page":"AIBECS functions","title":"AIBECS functions","text":"mismatch\n∇mismatch","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"EditURL = \"https://github.com/briochemc/AIBECS.jl/blob/master/docs/lit/tutorials/1_ideal_age.jl\"","category":"page"},{"location":"tutorials/1_ideal_age/#ideal-age-1","page":"Ideal age","title":"Ideal age","text":"","category":"section"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"note: Note\nAll the AIBECS tutorials and how-to guides are available as Jupyter notebooks. You can execute them online with binder or just view them with nbviewer by clicking on the badges above!","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"The tracer equation for the ideal age is","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"left(partial_t + mathbfTright) boldsymbola = 1 - fracboldsymbolaτ  (boldsymbolz  z_0)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"where the sink term on the right clamps the age to 0 at the surface (where boldsymbolz  z_0). The smaller the timescale tau, the quicker boldsymbola is restored to 0 at the surface.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"AIBECS can interpret tracer equations as long as you arrange them under the generic form:","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"big(partial_t + mathbfT(boldsymbolp) big) boldsymbolx = boldsymbolG(boldsymbolx boldsymbolp)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"where mathbfT(boldsymbolp) is the transport, boldsymbolG(boldsymbolx boldsymbolp) is the net local sources and sinks, and boldsymbolp is the vector of model parameters. We will then use the AIBECS to simulate the ideal age by finding the steady-state of the system, i.e., the solution of","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"partial_t boldsymbolx = boldsymbolF(boldsymbolx boldsymbolp) = boldsymbolG(boldsymbolx boldsymbolp) - mathbfT(boldsymbolp)  boldsymbolx = 0","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"In this tutorial, we will simulate the ideal age by","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"defining functions for T(p) and G(x,p),\ndefining the parameters p,\ngenerating the state function F(x,p) and solving the associated steady-state problem,\nand finally making a plot of our simulated ideal age.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"We start by telling Julia that we want to use the AIBECS package and the OCIM2 circulation (the Ocean Circulation Inverse Model[1]).","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"[1]: DeVries, T., & Holzer, M. (2019). Radiocarbon and helium isotope constraints on deep ocean ventilation and mantle‐³He sources. Journal of Geophysical Research: Oceans, 124, 3036–3057. doi:10.1029/2018JC014716","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"using AIBECS\ngrd, TOCIM2 = OCIM2.load()","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"note: Note\nIf it's your first time, Julia will ask you to download the OCIM2, in which case you should accept (i.e., type y and \"return\"). Once downloaded, AIBECS will remember where it downloaded the file and it will only load it from your laptop.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"grd is an OceanGrid object containing information about the 3D grid of the OCIM2 circulation and TOCIM2 is the transport matrix representing advection and diffusion.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"We define the function T(p) as","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"T(p) = TOCIM2","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"(It turns out the circulation T(p) does not effectively depend on p but that's how we must define it anyway, i.e., as a function of p.)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"The local sources and sinks for the age take the form","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"function G(x,p)\n    @unpack τ, z₀ = p\n    return @. 1 - x / τ * (z < z₀)\nend","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"as per the tracer equation. The @unpack line unpacks the parameters τ and z₀. The return line returns the net sources and sinks. (The @. \"macro\" tells Julia that the operations apply to every element.)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"We can define the vector z of depths with depthvec.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"z = depthvec(grd)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"Now we must construct a type for p the parameters. This type must contain our parameters τ and z₀.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"struct IdealAgeParameters{U} <: AbstractParameters{U}\n    τ::U\n    z₀::U\nend","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"The type is now ready for us to generate an instance of the parameter p. Let's use τ = 1.0 (s) and z₀ = 20.0 (m) .","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"p = IdealAgeParameters(1.0, 20.0)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"We now use the AIBECS to generate the state function boldsymbolF (and its Jacobian) via","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"F, ∇ₓF = state_function_and_Jacobian(T, G)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"(∇ₓF is the Jacobian of the state function nabla_boldsymbolxboldsymbolF, calculated automatically using dual numbers.)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"Now that F(x,p), and p are defined, we are going to solve for the steady-state. But first, we must create a SteadyStateProblem object that contains F, ∇ₓF, p, and an initial guess x_init for the age. (SteadyStateProblem is specialized from DiffEqBase for AIBECS models.)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"Let's make a vector of 0's for our initial guess.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"nb = sum(iswet(grd))  # number of wet boxes\nx_init = zeros(nb)    # Start with age = 0 everywhere","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"Now we can create our SteadyStateProblem instance","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"prob = SteadyStateProblem(F, ∇ₓF, x_init, p)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"And finally, we can solve this problem, using the AIBECS CTKAlg() algorithm,","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"age = solve(prob, CTKAlg())","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"This should take a few seconds.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"To conclude this tutorial, let's have a look at the age using AIBECS' plotting recipes and Plots.jl.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"using Plots","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"We first convert the age in years (because the default SI unit we used, i.e., seconds, is a bit small relative to global ocean timescales).","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"age_in_yrs = age * u\"s\" .|> u\"yr\"","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"And we take a horizontal slice at about 2000m.","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"horizontalslice(age_in_yrs, grd, depth=2000u\"m\", color=:magma)","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"That's it for this tutorial... Good job!","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"","category":"page"},{"location":"tutorials/1_ideal_age/#","page":"Ideal age","title":"Ideal age","text":"This page was generated using Literate.jl.","category":"page"}]
}

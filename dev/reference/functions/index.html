<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AIBECS interface (functions and types) · AIBECS.jl</title><meta name="title" content="AIBECS interface (functions and types) · AIBECS.jl"/><meta property="og:title" content="AIBECS interface (functions and types) · AIBECS.jl"/><meta property="twitter:title" content="AIBECS interface (functions and types) · AIBECS.jl"/><meta name="description" content="Documentation for AIBECS.jl."/><meta property="og:description" content="Documentation for AIBECS.jl."/><meta property="twitter:description" content="Documentation for AIBECS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AIBECS.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AIBECS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/1_ideal_age/">Ideal age</a></li><li><a class="tocitem" href="../../tutorials/2_radiocarbon/">Radiocarbon</a></li><li><a class="tocitem" href="../../tutorials/3_Pmodel/">A coupled PO₄–POP model</a></li><li><a class="tocitem" href="../../tutorials/4_dustmodel/">A dust model</a></li><li><a class="tocitem" href="../../tutorials/5_river_discharge/">River discharge</a></li><li><a class="tocitem" href="../../tutorials/6_groundwater_discharge/">Groundwater discharge</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howtos/1_parameters/">Parameters guide</a></li><li><a class="tocitem" href="../../howtos/2_plot/">Plot basic things</a></li><li><a class="tocitem" href="../../howtos/3_cruiseplot/">Plot transect/cruise data</a></li><li><a class="tocitem" href="../../howtos/4_fluxes/">Estimate fluxes</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/1_concept/">Concept</a></li><li><a class="tocitem" href="../../explanation/2_tracer_transport_operators/">Tracer transport</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>AIBECS interface (functions and types)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>AIBECS interface (functions and types)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AIBECS interface (functions and types)</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AIBECS-interface-(functions-and-types)"><a class="docs-heading-anchor" href="#AIBECS-interface-(functions-and-types)">AIBECS interface (functions and types)</a><a id="AIBECS-interface-(functions-and-types)-1"></a><a class="docs-heading-anchor-permalink" href="#AIBECS-interface-(functions-and-types)" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="AIBECS.AbstractParameters"><a class="docstring-binding" href="#AIBECS.AbstractParameters"><code>AIBECS.AbstractParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractParameters{T} &lt;: AbstractVector{T}</code></pre><p>An abstract type for AIBECS model parameters.</p><p>Parameters in AIBECS use the following convenience packages:</p><ul><li>Parameters</li><li>FieldMetadata</li><li>FieldDefaults</li><li>Flatten</li><li>Unitful</li><li>DataFrames</li><li>Distributions</li></ul><p>These aim to allow for some nice features, which include</p><ul><li>nice syntax for unpacking parameters in functions via the <code>@unpack</code> macro (fron UnPack.jl)</li><li>additional metadata on parameters</li><li>easy conversion to and from vectors</li><li>use of units and automatic conversions if necessary</li><li>pretty table-format displays</li><li>loading and saving to and from CSV files</li><li>prior estimates for bayesian inference and optimization</li></ul><p>See the list of examples to get an idea of how to generate parameters for your model.</p><p><strong>Examples</strong></p><p>Generate a simple parameter type via</p><pre><code class="language-julia-repl hljs">julia&gt; struct SimpleParams{T} &lt;: AbstractParameters{T}
           α::T
           β::T
           γ::T
       end
SimpleParams</code></pre><p>To create an instance of the <code>SimpleParams(Float64)</code> type, you can do</p><pre><code class="language-julia-repl hljs">julia&gt; p = SimpleParams(1.0, 2.0, 3.0)
SimpleParams{Float64}
│ Row │ Symbol │ Value   │
│     │ Symbol │ Float64 │
├─────┼────────┼─────────┤
│ 1   │ α      │ 1.0     │
│ 2   │ β      │ 2.0     │
│ 3   │ γ      │ 3.0     │</code></pre><p>One of the core features from Parameters is unpacking in functions, e.g.,</p><pre><code class="language-julia-repl hljs">julia&gt; function simplef(p)
           @unpack α, γ = p
           return α + γ
       end
simplef (generic function with 1 method)

julia&gt; simplef(p) # 1.0 + 3.0
4.0</code></pre><p>More complex examples are permitted by adding metadata (thanks to FieldMetadata.jl). You can add units</p><pre><code class="language-julia-repl hljs">julia&gt; @units struct UnitParams{T} &lt;: AbstractParameters{T}
           α::T | u&quot;km&quot;
           β::T | u&quot;hr&quot;
           γ::T | u&quot;m/s&quot;
       end ;

julia&gt; p = UnitParams(1.0, 2.0, 3.0)
UnitParams{Float64}
│ Row │ Symbol │ Value   │ Unit     │
│     │ Symbol │ Float64 │ Unitful… │
├─────┼────────┼─────────┼──────────┤
│ 1   │ α      │ 1.0     │ km       │
│ 2   │ β      │ 2.0     │ hr       │
│ 3   │ γ      │ 3.0     │ m s^-1   │</code></pre><p>Note that when adding units to your parameters, they will be converted to SI when unpacked, as in, e.g.,</p><pre><code class="language-julia-repl hljs">julia&gt; function speed(p)
           @unpack α, β, γ = p
           return α / β + γ
       end
speed (generic function with 1 method)

julia&gt; speed(p) # (1.0 km / 2.0 hr + 3 m/s) in m/s
3.138888888888889</code></pre><p>Another example for optimizable/flattenable parameters</p><pre><code class="language-julia-repl hljs">julia&gt; @initial_value @units @flattenable struct OptParams{T} &lt;: AbstractParameters{T}
           α::T | 3.6 | u&quot;km&quot;  | true
           β::T | 1.0 | u&quot;hr&quot;  | false
           γ::T | 1.0 | u&quot;m/s&quot; | true
       end ;

julia&gt; p = OptParams(initial_value(OptParams)...)
OptParams{Float64}
│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Optimizable │
│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Bool        │
├─────┼────────┼─────────┼───────────────┼──────────┼─────────────┤
│ 1   │ α      │ 3.6     │ 3.6           │ km       │ 1           │
│ 2   │ β      │ 1.0     │ 1.0           │ hr       │ 0           │
│ 3   │ γ      │ 1.0     │ 1.0           │ m s^-1   │ 1           │</code></pre><p>Thanks to the FieldMetaData interface, you can chain the following preloaded metadata:</p><ul><li>initial_value</li><li>units (from Unitful.jl)</li><li>prior (from Distributions.jl)</li><li>description (<code>String</code>)</li><li>bounds (2-element <code>Tuple</code>)</li><li>logscaled (<code>Bool</code>)</li><li>flattenable (to convert to vectors of optimizable parameters only)</li><li>reference (<code>String</code>)</li></ul><p>Here is an example of parameter with all the possible metadata available in AIBECS:</p><pre><code class="language-julia-repl hljs">julia&gt; @initial_value @units @prior @description @bounds @logscaled @flattenable @reference struct FullParams{T} &lt;: AbstractParameters{T}
           α::T | 1.0 | u&quot;km&quot;  | Normal(0,1)    | &quot;The distance&quot;   | (-Inf, Inf) | false | false | &quot;Jean et al., 2042&quot;
           β::T | 2.0 | u&quot;hr&quot;  | LogNormal(0,1) | &quot;The time&quot;       | (   0, Inf) | true  | true  | &quot;Claude et al. 1983&quot;
           γ::T | 3.0 | u&quot;mol&quot; | Normal(1,2)    | &quot;The # of moles&quot; | (  -1,   1) | false | true  | &quot;Dusse et al. 2000&quot;
       end ;

julia&gt; FullParams(4.0, 5.0, 6.0)
FullParams{Float64}
│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Prior                            │ Description    │ Bounds      │ Logscaled │ Optimizable │ Reference          │
│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Distribu…                        │ String         │ Tuple…      │ Bool      │ Bool        │ String             │
├─────┼────────┼─────────┼───────────────┼──────────┼──────────────────────────────────┼────────────────┼─────────────┼───────────┼─────────────┼────────────────────┤
│ 1   │ α      │ 4.0     │ 1.0           │ km       │ Normal{Float64}(μ=0.0, σ=1.0)    │ The distance   │ (-Inf, Inf) │ 0         │ 0           │ Jean et al., 2042  │
│ 2   │ β      │ 5.0     │ 2.0           │ hr       │ LogNormal{Float64}(μ=0.0, σ=1.0) │ The time       │ (0, Inf)    │ 1         │ 1           │ Claude et al. 1983 │
│ 3   │ γ      │ 6.0     │ 3.0           │ mol      │ Normal{Float64}(μ=1.0, σ=2.0)    │ The # of moles │ (-1, 1)     │ 0         │ 1           │ Dusse et al. 2000  │</code></pre><p>Note that there is no check that the metadata you give is consistent. These metadata will hopefully be useful for advanced usage of AIBECS, e.g., using prior information and/or bounds for optimization.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.AgedJacobianFactors"><a class="docstring-binding" href="#AIBECS.AgedJacobianFactors"><code>AIBECS.AgedJacobianFactors</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AgedJacobianFactors</code></pre><p>Type containing the Jacobian Factors and the age of the Jacobian. This allows for the Shamanskii method to not update the Jacobian at each iterate.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.DIVO-Tuple{Any}"><a class="docstring-binding" href="#AIBECS.DIVO-Tuple{Any}"><code>AIBECS.DIVO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DIVO(grd)</code></pre><p>Build the <code>DIVO</code> operator such that</p><pre><code class="language-julia hljs">DIVO * ϕ_top = 1/δz * (ϕ_top - ϕ_top[below]) ≈ dΦ/δz.</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.FATO-Tuple{Vector, Any}"><a class="docstring-binding" href="#AIBECS.FATO-Tuple{Vector, Any}"><code>AIBECS.FATO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FATO(w_top, Iabove)</code></pre><p>Build the <code>FATO</code> operator for a particle sinking speed <code>w_top</code></p><p>(<code>w_top</code> is the sinking speed at the top of each grid cell.)</p><p>The <code>FATO</code> operator is defined by</p><pre><code class="language-julia hljs">FATO * x = w_top * x(above) ≈ ϕ_top.</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.PFDO-NTuple{8, Any}"><a class="docstring-binding" href="#AIBECS.PFDO-NTuple{8, Any}"><code>AIBECS.PFDO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PFDO(grd, δz, w_top, w_bot, frac_seafloor, cumfrac_seafloor, fsedremin, Iabove)</code></pre><p>Returns the particle-flux-divergence operator for a given sinking speed as a function of depth.</p><p>This is a slightly different construction where I take in top and bottom settling velocities, and where the bottom one can be modified to further allow a fraction of particles to sink through (buried into) the sea floor.</p><p>Below is a detailed explanation of how this function computes the particle-flux divergence. Take these 3 boxes on top of each other:</p><pre><code class="language-julia hljs">┌──────────────────┐
│ water            │
│←----c----→       │
├───────────┲━━━━━━┥ ←- Φ_top
│           ┃⣿⣿⣿⣿⣿⣿│
│           ┃⣿⣿⣿⣿⣿⣿│
│←-d-→ ←-a-→┃⣿⣿⣿⣿⣿⣿│
├─────┲━━━━━┹──────┤ ←- Φ_bot
│     ┃←----b-----→│
│     ┃⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿│
│     ┃⣿⣿⣿ land ⣿⣿⣿│
│     ┃⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿│
└━━━━━┹────────────┘</code></pre><p>A part of each of these boxes is water, while the rest is land. For the middle box, we will use the fractional area <code>a = frac_seafloor</code> of seafloor, and the cumulated fractional area <code>b = cumfrac_seafloor</code> of seafloor, to determine the flux of particles at the top <code>ϕ_top</code> and bottom <code>ϕ_bot</code>.</p><p>From the top box, only the particles in the water can enter the middle box. So the flux at the top of the middle box, <code>ϕ_top</code>, is proportional to <code>c = 1 - Iabove * b</code>. At the bottom of the middle box, we have to take care of the case of particles hitting the sediments and potentially buried there, or kept in the water. For the part going through the area <code>d</code>, the flux is proportional to <code>d = 1 - b</code>. For the part going through <code>a</code> (hitting the sediments), the flux is proportional to <code>a * (1 - f)</code> where <code>f</code> is the fraction of particles forcibly kept in the water. (So if <code>f = 0</code>, the particles appear to move out of the middle box, but are not carried into the bottom one, and thus are removed from the system / buried.)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.PFDO-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AIBECS.PFDO-Tuple{Any, Any, Any}"><code>AIBECS.PFDO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PFDO(w, DIVO, Iabove)</code></pre><p>Returns <code>DIVO * FATO(w, Iabove)</code></p><p>This function is useful to avoid reconstructing <code>DIVO</code> and <code>Iabove</code> every time. It should allow for faster runs.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.PFDO-Tuple{Any}"><a class="docstring-binding" href="#AIBECS.PFDO-Tuple{Any}"><code>AIBECS.PFDO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PFDO(grd; w_top)</code></pre><p>Builds the particle-flux-divergence operator <code>PFDO</code> for a given particle sinking speed (<code>w_top</code>).</p><p>Schematic of a grid cell:</p><pre><code class="language-julia hljs">     top  ┌─────────────────────────────────┐   ┬
          │      ↓ w_top          ↓ Φ_top   │   │
          │ (settling velovity)    (flux)   │   │
          │                                 │   │
          │            x                    │   δz
          │      (particle conc.)           │   │
          │                                 │   │
          │                                 │   │
  bottom  └─────────────────────────────────┘   ┴</code></pre><ul><li><code>δz</code> is the height of grid cell [m]</li><li><code>w_top</code> is the particle sinking speed at the top of the grid cell [m s⁻¹]</li><li><code>Φ_top</code> is the flux at the top of the grid cell [mol m⁻² s⁻¹]</li><li><code>x</code> is the particle concentration of the cell [mol m⁻³]</li></ul><p>The PFDO is defined by</p><pre><code class="language-julia hljs">PFDO * x = δΦ/δz ≈ dΦ/dz,</code></pre><p>i.e., so that applied to <code>x</code> it approximates the flux divergence of <code>x</code>, dΦ/δz. It is calculated as the matrix product of DIVO and FATO:</p><pre><code class="language-julia hljs">PFDO = DIVO * FATO.</code></pre><p>where the divergence operator <code>DIVO</code>, is defined by (<code>z</code> increasing downward)</p><pre><code class="language-julia hljs">DIVO * ϕ_top = 1/δz * (ϕ_top[below] - ϕ_top) = δϕ/δz ≈ dΦ/δz.</code></pre><p>and FATO, the flux-at-top operator, is defined by</p><pre><code class="language-julia hljs">FATO * x = w_top * x[above] ≈ ϕ_top.</code></pre><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PFDO(grd, w_top=1.0) # 1.0 m/s (SI units assumed)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.flattenable_symbols-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#AIBECS.flattenable_symbols-Tuple{T} where T&lt;:AbstractParameters"><code>AIBECS.flattenable_symbols</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flattenable_symbols(p)</code></pre><p>Returns the flattenable symbols in <code>p</code>.</p><p>The flattenable symbols are those symbols that are kepth when using <code>p</code> as a vector, e.g., when doing <code>vec(p)</code>. (Useful when passing parameters to an optimization routine expeting a vector of optimizable parameters.)</p><p>Can also be used directly on the type of <code>p</code> (because the flattenable symbols of <code>p::T</code> are contained in the type <code>T</code>).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.flattenable_values-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#AIBECS.flattenable_values-Tuple{T} where T&lt;:AbstractParameters"><code>AIBECS.flattenable_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flattenable_values(p::T) where {T &lt;: AbstractParameters}</code></pre><p>Returns a vector of the <strong>flattenable</strong> values of <code>p</code>.</p><p>Note that <code>vec(p)</code> is different from <code>values(p)</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.latex-Tuple{AbstractParameters}"><a class="docstring-binding" href="#AIBECS.latex-Tuple{AbstractParameters}"><code>AIBECS.latex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">latex(p)</code></pre><p>Returns a LaTeX-formatted table of the parameters.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.localderivative-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#AIBECS.localderivative-Tuple{Any, Any, Any}"><code>AIBECS.localderivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">localderivative(G, x, p)
localderivative(Gᵢ, xs, i, p)
localderivative(Gᵢ, dx, xs, i, p)</code></pre><p>Returns the &quot;local&quot; derivative of <code>G</code> (or <code>Gᵢ</code>), i.e., equivalent to the vector</p><pre><code class="language-julia hljs">∇ₓG(x,p) * ones(size(x))</code></pre><p>but using ForwardDiff&#39;s Jacobian instead.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.minimap!-Tuple"><a class="docstring-binding" href="#AIBECS.minimap!-Tuple"><code>AIBECS.minimap!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimap(grd; central_longitude=200°)</code></pre><p>Plots a surface map of grd with no ticks, labels, or colorbar.</p><p>The goal of this function is to provide a way to plot both a minimap and a cruise track when plotting a transect:</p><pre><code class="language-julia hljs">plottransect(dummy, grd; ct=sort(ct))
plot!(inset_subplots=bbox(0.73,0.73,0.15,0.15), subplot=2)
minimap!(grd; subplot=2)
plotcruisetrack!(sort(ct), subplot=2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.minimap!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><a class="docstring-binding" href="#AIBECS.minimap!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>AIBECS.minimap!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimap(grd; central_longitude=200°)</code></pre><p>Plots a surface map of grd with no ticks, labels, or colorbar.</p><p>The goal of this function is to provide a way to plot both a minimap and a cruise track when plotting a transect:</p><pre><code class="language-julia hljs">plottransect(dummy, grd; ct=sort(ct))
plot!(inset_subplots=bbox(0.73,0.73,0.15,0.15), subplot=2)
minimap!(grd; subplot=2)
plotcruisetrack!(sort(ct), subplot=2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.minimap-Tuple"><a class="docstring-binding" href="#AIBECS.minimap-Tuple"><code>AIBECS.minimap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimap(grd; central_longitude=200°)</code></pre><p>Plots a surface map of grd with no ticks, labels, or colorbar.</p><p>The goal of this function is to provide a way to plot both a minimap and a cruise track when plotting a transect:</p><pre><code class="language-julia hljs">plottransect(dummy, grd; ct=sort(ct))
plot!(inset_subplots=bbox(0.73,0.73,0.15,0.15), subplot=2)
minimap!(grd; subplot=2)
plotcruisetrack!(sort(ct), subplot=2)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.mismatch-NTuple{4, Any}"><a class="docstring-binding" href="#AIBECS.mismatch-NTuple{4, Any}"><code>AIBECS.mismatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mismatch(x, xobs, σ²xobs, v)</code></pre><p>Volume-weighted mismatch of modelled tracer <code>x</code> against observed mean, <code>xobs</code>, given observed variance, <code>σ²xobs</code>, and volumes <code>v</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.onlykeep-Tuple{MetadataArray, Any}"><a class="docstring-binding" href="#AIBECS.onlykeep-Tuple{MetadataArray, Any}"><code>AIBECS.onlykeep</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">onlykeep(x::MetadataArray, idx)</code></pre><p>Returns <code>x[idx]</code> but also applies the index to the metadata that is originally of the same length as <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.p2λ-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#AIBECS.p2λ-Tuple{T} where T&lt;:AbstractParameters"><code>AIBECS.p2λ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">p2λ(p::AbstractParameters)</code></pre><p>Converts <code>p</code> to a real-valued vector for optimization. (referred to as the λ space in AIBECS)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotdepthprofile-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotdepthprofile-Tuple{Any, Any}"><code>AIBECS.plotdepthprofile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotdepthprofile(x, grd; lonlat)</code></pre><p>Plots the profile of tracer <code>x</code> interpolated at <code>lonlat=(x,y)</code> coordinates.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plothorizontalmean-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plothorizontalmean-Tuple{Any, Any}"><code>AIBECS.plothorizontalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plothorizontalaverage(x, grd; mask=1)</code></pre><p>Plots a horizontal average of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plothorizontalslice-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plothorizontalslice-Tuple{Any, Any}"><code>AIBECS.plothorizontalslice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plothorizontalslice(x, grd; depth)</code></pre><p>Plots a heatmap of the horizontal slice of tracer <code>x</code> at depth <code>depth</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotmeridionalmean-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotmeridionalmean-Tuple{Any, Any}"><code>AIBECS.plotmeridionalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotmeridionalmean(x, grd; mask=1)</code></pre><p>Plots a meridional average of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotmeridionalslice-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotmeridionalslice-Tuple{Any, Any}"><code>AIBECS.plotmeridionalslice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotmeridionalslice(x, grd; lon)</code></pre><p>Plots a meridional slice of tracer <code>x</code> at longitude <code>lon</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameter!-Tuple"><a class="docstring-binding" href="#AIBECS.plotparameter!-Tuple"><code>AIBECS.plotparameter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameter(p::AbstractParameters, s)</code></pre><p>Plots the PDF of parameter <code>p</code> with symbol <code>s</code></p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameter!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><a class="docstring-binding" href="#AIBECS.plotparameter!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>AIBECS.plotparameter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameter(p::AbstractParameters, s)</code></pre><p>Plots the PDF of parameter <code>p</code> with symbol <code>s</code></p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameter-Tuple"><a class="docstring-binding" href="#AIBECS.plotparameter-Tuple"><code>AIBECS.plotparameter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameter(p::AbstractParameters, s)</code></pre><p>Plots the PDF of parameter <code>p</code> with symbol <code>s</code></p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameters!-Tuple"><a class="docstring-binding" href="#AIBECS.plotparameters!-Tuple"><code>AIBECS.plotparameters!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameters(p::AbstractParameters)</code></pre><p>Plots the PDF of all the flattenable parameters in <code>p</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameters!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><a class="docstring-binding" href="#AIBECS.plotparameters!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>AIBECS.plotparameters!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameters(p::AbstractParameters)</code></pre><p>Plots the PDF of all the flattenable parameters in <code>p</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotparameters-Tuple"><a class="docstring-binding" href="#AIBECS.plotparameters-Tuple"><code>AIBECS.plotparameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotParameters(p::AbstractParameters)</code></pre><p>Plots the PDF of all the flattenable parameters in <code>p</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotstencil!-Tuple"><a class="docstring-binding" href="#AIBECS.plotstencil!-Tuple"><code>AIBECS.plotstencil!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotStencil(st)</code></pre><p>Plots the stencil <code>st</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotstencil!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><a class="docstring-binding" href="#AIBECS.plotstencil!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>AIBECS.plotstencil!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotStencil(st)</code></pre><p>Plots the stencil <code>st</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotstencil-Tuple"><a class="docstring-binding" href="#AIBECS.plotstencil-Tuple"><code>AIBECS.plotstencil</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PlotStencil(st)</code></pre><p>Plots the stencil <code>st</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plottransect-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plottransect-Tuple{Any, Any}"><code>AIBECS.plottransect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plottransect(x, grd; ct=ct)</code></pre><p>Plots the transect of tracer <code>x</code> along transect <code>ct</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotverticalmean-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotverticalmean-Tuple{Any, Any}"><code>AIBECS.plotverticalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotverticalaverage(x, grd, mask=1)</code></pre><p>Plots the vertical average of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotzonalmean-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotzonalmean-Tuple{Any, Any}"><code>AIBECS.plotzonalmean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotzonalmean(x, grd; mask=1)</code></pre><p>Plots a zonal average of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plotzonalslice-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plotzonalslice-Tuple{Any, Any}"><code>AIBECS.plotzonalslice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotzonalslice(x, grd; lat)</code></pre><p>Plots a zonal slice of tracer <code>x</code> at latitude <code>lat</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plot∫dx-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plot∫dx-Tuple{Any, Any}"><code>AIBECS.plot∫dx</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotzonalintegral(x, grd; mask=1)</code></pre><p>Plots a zonal integral of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plot∫dxdy-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plot∫dxdy-Tuple{Any, Any}"><code>AIBECS.plot∫dxdy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">horizontalintegral(x, grd; mask=1)</code></pre><p>Plots a horizontal integral of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plot∫dy-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plot∫dy-Tuple{Any, Any}"><code>AIBECS.plot∫dy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotmeridionalintegral(x, grd; mask=1)</code></pre><p>Plots a meridional integral of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.plot∫dz-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.plot∫dz-Tuple{Any, Any}"><code>AIBECS.plot∫dz</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">plotverticalintegral(x, grd, mask=1)</code></pre><p>Plots the vertical integral of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ratioatstation!-Tuple"><a class="docstring-binding" href="#AIBECS.ratioatstation!-Tuple"><code>AIBECS.ratioatstation!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RatioAtStation(x, y, grd, station, depthlims=(0,Inf))</code></pre><p>Plots a meridional transect of tracer <code>x</code> along cruise track <code>ct</code>.</p><p>The keyword argument <code>zlims=(ztop, zbottom)</code> can be provided if you only want to only plot for depths <code>z ∈ (ztop, zbottom)</code>. (<code>z</code> is positive downwards in this case)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ratioatstation!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><a class="docstring-binding" href="#AIBECS.ratioatstation!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}"><code>AIBECS.ratioatstation!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RatioAtStation(x, y, grd, station, depthlims=(0,Inf))</code></pre><p>Plots a meridional transect of tracer <code>x</code> along cruise track <code>ct</code>.</p><p>The keyword argument <code>zlims=(ztop, zbottom)</code> can be provided if you only want to only plot for depths <code>z ∈ (ztop, zbottom)</code>. (<code>z</code> is positive downwards in this case)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ratioatstation-Tuple"><a class="docstring-binding" href="#AIBECS.ratioatstation-Tuple"><code>AIBECS.ratioatstation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RatioAtStation(x, y, grd, station, depthlims=(0,Inf))</code></pre><p>Plots a meridional transect of tracer <code>x</code> along cruise track <code>ct</code>.</p><p>The keyword argument <code>zlims=(ztop, zbottom)</code> can be provided if you only want to only plot for depths <code>z ∈ (ztop, zbottom)</code>. (<code>z</code> is positive downwards in this case)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.reconstruct-Union{Tuple{V}, Tuple{T}, Tuple{Type{T}, Vector{V}}} where {T&lt;:AbstractParameters, V}"><a class="docstring-binding" href="#AIBECS.reconstruct-Union{Tuple{V}, Tuple{T}, Tuple{Type{T}, Vector{V}}} where {T&lt;:AbstractParameters, V}"><code>AIBECS.reconstruct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reconstruct(T, v)</code></pre><p>Reconstructs the parameter of type <code>T</code> from flattenable vector <code>v</code>.</p><p>Note that <code>T</code> must be the generic type (or type wrapper if you will). I.e., <code>T</code> must <em>not</em> include the parametric scalar type, as in, use <code>T == Params</code> instead of <code>T == Params{Float64}</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.smooth_operator-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.smooth_operator-Tuple{Any, Any}"><code>AIBECS.smooth_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth_operator(grd, T; σs=(1.0, 1.0, 0.25))</code></pre><p>return a matrix of the same size and sparsity as <code>T</code> that smoothes data using a Gaussian Kernel for values, but conserving mass.</p><p>This matrix can also likely be used as a covariance matrix for observations in a Bayesian framework.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.split_state_function_and_Jacobian-Tuple{Tuple, Tuple, Tuple, Any}"><a class="docstring-binding" href="#AIBECS.split_state_function_and_Jacobian-Tuple{Tuple, Tuple, Tuple, Any}"><code>AIBECS.split_state_function_and_Jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">F, L, NL, ∇ₓF, ∇ₓL, ∇ₓNL, T = split_state_function_and_Jacobian(Ts, Ls, NLs, nb)</code></pre><p>Returns the state function <code>F</code> and its jacobian, <code>∇ₓF</code>, as well as a collection of split operators. This is experimental. Use at your own risk!</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.surfacemap-Tuple"><a class="docstring-binding" href="#AIBECS.surfacemap-Tuple"><code>AIBECS.surfacemap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">surfacemap(x, grd)</code></pre><p>Plots a surface heatmap of tracer <code>x</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.symbols-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#AIBECS.symbols-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractParameters"><code>AIBECS.symbols</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbols(p)</code></pre><p>Returns the symbols in <code>p</code>.</p><p>Can also be used directly on the type of <code>p</code> (because the symbols of <code>p::T</code> are contained in the type <code>T</code>).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.table-Tuple{AbstractParameters}"><a class="docstring-binding" href="#AIBECS.table-Tuple{AbstractParameters}"><code>AIBECS.table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">table(p)</code></pre><p>Returns a <code>DataFrame</code> (a table) of <code>p</code>. Useful for printing and saving into an actual text/latex table.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.transportoperator-Tuple{Any, Any}"><a class="docstring-binding" href="#AIBECS.transportoperator-Tuple{Any, Any}"><code>AIBECS.transportoperator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transportoperator(grd, w)</code></pre><p>Returns the transportoperator for the given settling velocity <code>w</code>.</p><p>The settling velocity can be provided as either a scalar (e.g., <code>w = 100.0</code> in units of meters per second) or as a function of depth (e.g., <code>w(z) = 2z + 1</code>).</p><p><strong>Examples</strong></p><p>Create the particle flux divergence with settling velocity of 100m/s</p><pre><code class="language-julia-repl hljs">julia&gt; T = transportoperator(grd, 100.0)</code></pre><p>Or with settling velocity function w(z) = 2z + 1</p><pre><code class="language-julia-repl hljs">julia&gt; T = transportoperator(grd, z -&gt; 2z + 1)</code></pre><p>By default, the seafloor flux is set to zero, so that all the particles that reach it are remineralized there. You can let particles go through by setting <code>fsedremin=0.0</code>, via, e.g.,</p><pre><code class="language-julia-repl hljs">julia&gt; T = transportoperator(grd, z -&gt; 2z + 1; fsedremin=0.0)</code></pre><p>For finer control and advanced use, see the particle-flux divergence operator function, <code>PFDO</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.λ2p-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#AIBECS.λ2p-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:AbstractParameters"><code>AIBECS.λ2p</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">λ2p(T::Type{AbstractParameters}, λ::Vector)</code></pre><p>Converts real-valued vector <code>λ</code> back to parameters object <code>p</code>.</p><p>Note that the instance of your parameters type <code>T</code> is required here because it contains information on non-optimizable parameters and priors of optimizable parameters</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.∇mismatch-NTuple{4, Any}"><a class="docstring-binding" href="#AIBECS.∇mismatch-NTuple{4, Any}"><code>AIBECS.∇mismatch</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">∇mismatch(x, xobs, σ²xobs, v)</code></pre><p>Adjoint of the gradient of <code>mismatch(x, xobs, σ²xobs, v)</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{MetadataArray, Quantity}"><a class="docstring-binding" href="#Base.:*-Tuple{MetadataArray, Quantity}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(x::MetadataArray, q::Quantity)

Preserve metadata (and history of unit conversions) when multiplying `x` by a quantity.</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{T, Vector}} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{T, Vector}} where T&lt;:AbstractParameters"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(p::T, v::Vector) where {T &lt;: AbstractParameters}</code></pre><p>Adds the flattened vector <code>v</code> to <code>p</code>.</p><p><strong>Warning:</strong> This method for <code>+</code> is implemented only for differentiation using dual and hyperdual numbers. If you want to change the values of <code>p</code>, you should do so explicitly rather than use this <code>+</code> method.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.:\\-Tuple{AIBECS.AgedJacobianFactors, Any}"><a class="docstring-binding" href="#Base.:\\-Tuple{AIBECS.AgedJacobianFactors, Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">\(Jf::JacobianFactors, y)</code></pre><p>Dispatches backslash to work with all <code>JacobianFactors</code> subtypes.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractParameters"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(p::T, i) where {T &lt;: AbstractParameters}</code></pre><p>Returns the i-th element of vec(p).</p><p>This is not efficient and only used for testing the derivatives with ForwardDiff.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.length-Tuple{T} where T&lt;:AbstractParameters"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">length(p::AbstractParameter)</code></pre><p>Returns the length of the <strong>flattened/optimizable</strong> vector of <code>p</code>.</p><p>May be different from the number of parameters. Can also be used directly on the type of <code>p</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.size-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.size-Tuple{T} where T&lt;:AbstractParameters"><code>Base.size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">size(p::AbstractParameter)</code></pre><p>Returns the size of the <strong>flattened/optimizable</strong> vector of <code>p</code>.</p><p>May be different from the number of parameters. Can also be used directly on the type of <code>p</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.values-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.values-Tuple{T} where T&lt;:AbstractParameters"><code>Base.values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">values(p::T) where {T &lt;: AbstractParameters}</code></pre><p>Returns a vector of <strong>all</strong> the values of <code>p</code>.</p><p>Note that <code>values(p)</code> is different from <code>vec(p)</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.vec-Tuple{T} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Base.vec-Tuple{T} where T&lt;:AbstractParameters"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vec(p::T) where {T &lt;: AbstractParameters}</code></pre><p>Returns a <strong>SI-unit-converted</strong> vector of flattenable values of <code>p</code>.</p><p>Note that <code>vec(p) ≠ flattenable_values(p)</code> if <code>p</code> has units.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Bijectors.bijector-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractParameters"><a class="docstring-binding" href="#Bijectors.bijector-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractParameters"><code>Bijectors.bijector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bijector(T::AbstractParameters [, k::Symbol])</code></pre><p>Returns the function for the change of variables of the parameters.</p><p>The function is a bijection from the supports/domains of the priors to ℝⁿ, from the Bijectors.jl package. You can specify the parameter symbol to get the bijector of that parameter.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="CommonSolve.solve-Tuple{SciMLBase.AbstractNonlinearProblem, CTKAlg}"><a class="docstring-binding" href="#CommonSolve.solve-Tuple{SciMLBase.AbstractNonlinearProblem, CTKAlg}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(prob::SciMLBase.AbstractSteadyStateProblem,
      alg::CTKAlg;
      nrm=norm,
      τstop=1e12*365*24*60*60,
      preprint=&quot;&quot;,
      maxItNewton=50)</code></pre><p>Solves <code>prob</code> using an AIBECS-customized version of C.T.Kelley Shamanskii-method algorithm.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="UnPack.unpack-Union{Tuple{f}, Tuple{T}, Tuple{T, Val{f}}} where {T&lt;:AbstractParameters, f}"><a class="docstring-binding" href="#UnPack.unpack-Union{Tuple{f}, Tuple{T}, Tuple{T, Val{f}}} where {T&lt;:AbstractParameters, f}"><code>UnPack.unpack</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unpack(p &lt;: AbstractParameters, s)</code></pre><p>Unpacks the parameter <code>s</code> from <code>p</code>.</p><p>Note this is specialized and will convert the parameter value to SI units.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Unitful.upreferred-Tuple{MetadataArray}"><a class="docstring-binding" href="#Unitful.upreferred-Tuple{MetadataArray}"><code>Unitful.upreferred</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">upreferred(x::MetadataArray)</code></pre><p>Converts <code>x.parent</code> to SI unit but keeps <code>x.metadata</code> for safekeeping.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Unitful.ustrip-Tuple{MetadataArray}"><a class="docstring-binding" href="#Unitful.ustrip-Tuple{MetadataArray}"><code>Unitful.ustrip</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ustrip(x::MetadataArray)</code></pre><p>Strips unit from <code>x.parent</code> but stores it in <code>x.metadata</code> for safekeeping.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.TwoBoxModel.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.TwoBoxModel.load-Tuple{}"><code>AIBECS.TwoBoxModel.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns <code>grd</code> and <code>T</code> (in that order).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.Primeau_2x2x2.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.Primeau_2x2x2.load-Tuple{}"><code>AIBECS.Primeau_2x2x2.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns <code>grd</code> and <code>T</code> (in that order).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.Archer_etal_2000.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.Archer_etal_2000.load-Tuple{}"><code>AIBECS.Archer_etal_2000.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns <code>grd</code> and <code>T</code> (in that order).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM0"><a class="docstring-binding" href="#AIBECS.OCIM0"><code>AIBECS.OCIM0</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The <code>OCIM0</code> module is used to load the OCIM v0 matrix and grid for use in AIBECS.</p><div class="admonition is-success" id="Tip-506b8475911626b8"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-506b8475911626b8" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCIM v0 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM0.load()</code></pre><p>See <em>DeVries and Primeau</em> (2011) and <em>Primeau et al.</em> (2013) for more details.</p></div></div><div class="admonition is-info" id="Note-40307c62296af439"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-40307c62296af439" title="Permalink"></a></header><div class="admonition-body"><p>The files, that are downloaded from a public and persistant URL in FigShare, were created with the code available at https://github.com/briochemc/OceanCirculations.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM0.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.OCIM0.load-Tuple{}"><code>AIBECS.OCIM0.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns the grid and the transport matrix.</p><div class="admonition is-success" id="Tip-c3fdba3b2a7bcf0f"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-c3fdba3b2a7bcf0f" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCIM0 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM0.load()</code></pre><p>See <em>DeVries and Primeau</em> (2011) and <em>Primeau et al.</em> (2013) for more details.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM1"><a class="docstring-binding" href="#AIBECS.OCIM1"><code>AIBECS.OCIM1</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The <code>OCIM1</code> module is used to load the OCIM v1 matrix and grid for use in AIBECS.</p><div class="admonition is-success" id="Tip-a1f743c33db49800"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-a1f743c33db49800" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCIM v1 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM1.load()</code></pre><p>See <em>DeVries and Primeau</em> (2011) and <em>Primeau et al.</em> (2013) for more details.</p></div></div><div class="admonition is-info" id="Note-40307c62296af439"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-40307c62296af439" title="Permalink"></a></header><div class="admonition-body"><p>The files, that are downloaded from a public and persistant URL in FigShare, were created with the code available at https://github.com/briochemc/OceanCirculations.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM1.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.OCIM1.load-Tuple{}"><code>AIBECS.OCIM1.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns the grid and the transport matrix.</p><div class="admonition is-success" id="Tip-a17fa2f87b4051f3"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-a17fa2f87b4051f3" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCIM1 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM1.load()</code></pre><p>See <em>DeVries and Primeau</em> (2011) and <em>DeVries</em> (2014) for more details.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM2"><a class="docstring-binding" href="#AIBECS.OCIM2"><code>AIBECS.OCIM2</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The <code>OCIM2</code> module is used to load the OCIM2 matrices and grid for use in AIBECS.</p><div class="admonition is-success" id="Tip-2f821ae22e5c21ba"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-2f821ae22e5c21ba" title="Permalink"></a></header><div class="admonition-body"><p>To load the default OCIM2 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2.load()</code></pre><p>But you can also load the other matrices by specifying which version you want, e.g.,</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2.load(version=&quot;OCIM2_KiHIGH_noHe&quot;)</code></pre><p>See <em>DeVries and Holzer</em> (2019) for more details</p></div></div><div class="admonition is-info" id="Note-40307c62296af439"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-40307c62296af439" title="Permalink"></a></header><div class="admonition-body"><p>The files, that are downloaded from a public and persistant URL in FigShare, were created with the code available at https://github.com/briochemc/OceanCirculations.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM2.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.OCIM2.load-Tuple{}"><code>AIBECS.OCIM2.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns the grid, the transport matrix, and the He fluxes.</p><div class="admonition is-success" id="Tip-beb2de293ee1c803"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-beb2de293ee1c803" title="Permalink"></a></header><div class="admonition-body"><p>To load the default OCIM2 matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2.load()</code></pre><p>But you can also load the other matrices by specifying which version you want, e.g.,</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2.load(version=&quot;KiHIGH_noHe&quot;)</code></pre><p>Add the <code>HeFluxes=true</code> keyword argument if you want the OCIM-produced He fields with ³He and ⁴He as 3rd and 4th arguments. (3rd and 4th output are returned as <code>nothing</code> for &quot;noHe&quot; versions).</p><p>See <em>DeVries and Holzer</em> (2019) for more details.</p><p>To see all available versions, do</p><pre><code class="nohighlight hljs">julia&gt; OCIM2.VERSIONS</code></pre></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM2_48L"><a class="docstring-binding" href="#AIBECS.OCIM2_48L"><code>AIBECS.OCIM2_48L</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The <code>OCIM2_48L</code> module is used to load the OCIM2-48L matrices and grid for use in AIBECS.</p><div class="admonition is-success" id="Tip-621e940708102d20"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-621e940708102d20" title="Permalink"></a></header><div class="admonition-body"><p>To load the default OCIM2_48L matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2_48L.load()</code></pre><p>But you can also load the other matrices by specifying which version you want, e.g.,</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCIM2_48L.load(version=&quot;OCIM2_48L_KiHIGH_noHe&quot;)</code></pre><p>See <em>DeVries and Holzer</em> (2019) for more details</p></div></div><div class="admonition is-info" id="Note-40307c62296af439"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-40307c62296af439" title="Permalink"></a></header><div class="admonition-body"><p>The files, that are downloaded from a public and persistant URL in FigShare, were created with the code available at https://github.com/briochemc/OceanCirculations.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCIM2_48L.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.OCIM2_48L.load-Tuple{}"><code>AIBECS.OCIM2_48L.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns the grid and the transport matrix of the OCIM2_48L model.</p><p>See <em>DeVries and Holzer</em> (2019) and <em>Holzer et al.</em> (2021) for more details.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCCA"><a class="docstring-binding" href="#AIBECS.OCCA"><code>AIBECS.OCCA</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The <code>OCCA</code> module is used to load the OCCA matrix and grid for use in AIBECS.</p><div class="admonition is-success" id="Tip-d2fb19347f9e446e"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-d2fb19347f9e446e" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCCA matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCCA.load()</code></pre><p>See <em>Forget</em> (2010) for more details</p></div></div><div class="admonition is-info" id="Note-40307c62296af439"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-40307c62296af439" title="Permalink"></a></header><div class="admonition-body"><p>The files, that are downloaded from a public and persistant URL in FigShare, were created with the code available at https://github.com/briochemc/OceanCirculations.</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.OCCA.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.OCCA.load-Tuple{}"><code>AIBECS.OCCA.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load</code></pre><p>Returns the grid and the transport matrix.</p><div class="admonition is-success" id="Tip-d2fb19347f9e446e"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-d2fb19347f9e446e" title="Permalink"></a></header><div class="admonition-body"><p>To load the OCCA matrix and grid, do</p><pre><code class="nohighlight hljs">julia&gt; grd, T = OCCA.load()</code></pre><p>See <em>Forget</em> (2010) for more details</p></div></div></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.AO.download_and_unpack-Tuple{}"><a class="docstring-binding" href="#AIBECS.AO.download_and_unpack-Tuple{}"><code>AIBECS.AO.download_and_unpack</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">download_and_unpack</code></pre><p>Downloads and unpacks the AO zip file from the MTEL website. Returns the local path of where the AO is installed for you.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.AeolianSources"><a class="docstring-binding" href="#AIBECS.AeolianSources"><code>AIBECS.AeolianSources</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>This <code>AeolianSources</code> module is to create aeolian sources for use in AIBECS-generated models.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.AeolianSources.load"><a class="docstring-binding" href="#AIBECS.AeolianSources.load"><code>AIBECS.AeolianSources.load</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load()</code></pre><p>Returns the 2D aeolian deposition fields from Chien et al. (2016).</p><p>You can specify a different dataset via, e.g.,</p><pre><code class="language-julia hljs">julia&gt; AeolianSources.load(&quot;Kok&quot;)</code></pre><p>At this stage, only two datasets are available:</p><ul><li><code>&quot;Chien&quot;</code> (default) for different dust types (fires, biofuels, dust, ...)</li><li><code>&quot;Kok&quot;</code> for dust from different regions of origin</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.GroundWaters.load-Tuple{}"><a class="docstring-binding" href="#AIBECS.GroundWaters.load-Tuple{}"><code>AIBECS.GroundWaters.load</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Z, lats, lons = load()</code></pre><p>Returns the fine resolution topography from ETOPO.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="OceanGrids.regrid-Union{Tuple{T}, Tuple{Array{AIBECS.GroundWaters.GroundWaterSource{T}, 1}, Any}} where T&lt;:Quantity"><a class="docstring-binding" href="#OceanGrids.regrid-Union{Tuple{T}, Tuple{Array{AIBECS.GroundWaters.GroundWaterSource{T}, 1}, Any}} where T&lt;:Quantity"><code>OceanGrids.regrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">regrid(gws, grd)</code></pre><p>Regrids and bins the groundwater discharge values into <code>grd</code> surface boxes.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ETOPO.bintopo-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any, Any}} where T"><a class="docstring-binding" href="#AIBECS.ETOPO.bintopo-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any, Any}} where T"><code>AIBECS.ETOPO.bintopo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bintopo(Z, lat, lon, grd)</code></pre><p>Bins the depths <code>Z</code> into at locations <code>(lat,lon)</code> onto <code>grd</code>. To be used with the ETOPO dataset to dertermine the amount of subgrid topography in each box area</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ETOPO.fractiontopo-Tuple{Any}"><a class="docstring-binding" href="#AIBECS.ETOPO.fractiontopo-Tuple{Any}"><code>AIBECS.ETOPO.fractiontopo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fractiontopo(grd)</code></pre><p>Returns the fraction of subgrid sediments in each wet box of grd.</p><p>Note that (i) points located above sea level are counted in the top layer, and (ii) points located in a dry box or below are counted in the deepest wet box.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.ETOPO.load"><a class="docstring-binding" href="#AIBECS.ETOPO.load"><code>AIBECS.ETOPO.load</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Z, lats, lons = ETOPO.load()</code></pre><p>Returns the fine resolution topography from ETOPO.</p><p>It is the same as</p><pre><code class="language-julia hljs">Z, lats, lons = ETOPO.load(:bedrock)</code></pre><p>If you want the ice elevation, use</p><pre><code class="language-julia hljs">Z, lats, lons = ETOPO.load(:ice)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.CirculationGeneration.T_advection-NTuple{4, Any}"><a class="docstring-binding" href="#AIBECS.CirculationGeneration.T_advection-NTuple{4, Any}"><code>AIBECS.CirculationGeneration.T_advection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T_advection(ϕ, sequence, v3D, nb)</code></pre><p>Returns the sparse matrix transport operator, <code>T</code>.</p><p><code>T</code> is such that it gives the flux divergence due to the volumetric flow rate <code>ϕ</code> (in m³ s⁻¹) going through all the boxes in <code>sequence</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.CirculationGeneration.T_advection-Union{Tuple{Tv}, Tuple{Tϕ}, Tuple{Tϕ, Any, Any, Array{Tv, 3}, Any}} where {Tϕ, Tv}"><a class="docstring-binding" href="#AIBECS.CirculationGeneration.T_advection-Union{Tuple{Tv}, Tuple{Tϕ}, Tuple{Tϕ, Any, Any, Array{Tv, 3}, Any}} where {Tϕ, Tv}"><code>AIBECS.CirculationGeneration.T_advection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T_advection(ϕ, orig, dest, v3D, nb)</code></pre><p>Returns the sparse matrix transport operator, <code>T</code>.</p><p><code>T</code> is such that it gives the flux divergence due to the volumetric flow rate <code>ϕ</code> (in m³ s⁻¹) from box <code>orig</code> to box <code>dest</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="AIBECS.CirculationGeneration.T_diffusion-NTuple{5, Any}"><a class="docstring-binding" href="#AIBECS.CirculationGeneration.T_diffusion-NTuple{5, Any}"><code>AIBECS.CirculationGeneration.T_diffusion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">T_diffusion(ν, i, j, v3D, nb)</code></pre><p>Returns the sparse matrix transport operator, <code>T</code>.</p><p><code>T</code> is such that it gives the flux divergence due to the volumetric mixing rate <code>ν</code> (in m³ s⁻¹) between boxes <code>i</code> and <code>j</code>.</p></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../explanation/2_tracer_transport_operators/">« Tracer transport</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 18 December 2025 01:17">Thursday 18 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

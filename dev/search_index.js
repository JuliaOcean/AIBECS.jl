var documenterSearchIndex = {"docs":
[{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/tutorials/5_river_discharge.jl\"","category":"page"},{"location":"tutorials/5_river_discharge/#river-discharge","page":"River discharge","title":"River discharge","text":"","category":"section"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"In this tutorial we will simulate a fictitious radioactive tracer that is injected into the ocean by the 200 largest rivers (by estimated discharge). The 200 major rivers dataset from Dai and Trenberth (2002) is available from within the AIBECS. Once \"born\", our ficitious tracer decays with a parameter timescale tau as it flows through ocean basins.","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"The 3D tracer equation is:","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"leftfracpartialpartial t + nabla cdot (boldsymbolu + mathbfKnabla)right x = s_mathsfrivers - x  tau","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"where nabla cdot left boldsymbolu - mathbfK nabla right represents the ocean circulation transport. (Tracer transport operators are described in the documentation.) The riverine source of the tracer is s_mathsfrivers, and x  tau is the decay rate.","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"In AIBECS, we must recast this equation in the generic form","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"leftfracpartialpartial t + mathbfT(boldsymbolp)right boldsymbolx = boldsymbolG(boldsymbolxboldsymbolp)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We start by telling Julia that we want to use the AIBECS and the OCIM2 transport matrix for the ocean circulation.","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"using AIBECS\ngrd, T_OCIM2 = OCIM2.load()","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"The transport is","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"T_radiorivers(p) = T_OCIM2","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"For the radioactive decay, we simply use","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"function decay(x, p)\n    @unpack τ = p\n    return x / τ\nend","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"To build the river sources, we will load the geographic locations and discharge (in m³ s⁻¹) from the Dai and Trenberth (2017) dataset.","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"RIVERS = Rivers.load()","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"This is an array of rivers, for which the typeRiver{T} contains the river's name, lat–lon coordinates, and discharge in m³ s⁻¹. For example, the first river is the Amazon","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"r = RIVERS[1]","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We can check the locations with","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"using Plots\nscatter([r.lon for r in RIVERS], [r.lat for r in RIVERS],\n        zcolor=log10.(ustrip.([r.VFR for r in RIVERS])),\n        clim=(0,7), colorbartitle=\"log₁₀(discharge / (1 m s⁻¹))\")","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We can regrid these into the OCIM2 grid and return the corresponding vector with","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"rivers = regrid(RIVERS, grd)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"(Note this regridding uses NearestNeighbors.jl to assign a wet box as the mouth of each river, which sometimes is not exactly the real location of the river mouth.)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We control the global magnitude of the river discharge, sigma (in mol s⁻¹), by making it a parameter of our model. For that, we separate the river source","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"s_mathsfrivers = sigma s_0","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"into global magnitude (sigma) and spatial pattern (s_0).","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"Since int s_0 mathrmdV = 1, s_0 can be computed by normalizing rivers. In Julia/AIBECS, this can be done by dividing rivers by the dot product v ⋅ rivers (or v'rivers in matrix form). (v ⋅ x is the discrete equivalent of the volume integral int x mathrmdV.)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"v = vector_of_volumes(grd)\ns_0 = rivers / (v'rivers)\nfunction s_rivers(p)\n    @unpack σ = p\n    return σ * ustrip.(s_0) # we must remove the units in AIBECS here :(\nend","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We then write the generic boldsymbolG function, which is","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"G_radiorivers(x,p) = s_rivers(p) - decay(x,p)","category":"page"},{"location":"tutorials/5_river_discharge/#Parameters","page":"River discharge","title":"Parameters","text":"","category":"section"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We specify some initial values for the parameters and also include units.","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"import AIBECS: @units, units\nimport AIBECS: @initial_value, initial_value\n@initial_value @units struct RadioRiversParameters{U} <: AbstractParameters{U}\n    τ::U | 5.0 | u\"yr\"\n    σ::U | 1.0 | u\"Gmol/yr\"\nend","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"Finally, thanks to the initial values we provided, we can instantiate the parameter vector succinctly as","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"p = RadioRiversParameters()","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"We generate the state function F and its Jacobian ∇ₓF,","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"F, ∇ₓF = state_function_and_Jacobian(T_radiorivers, G_radiorivers)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"generate the steady-state problem prob,","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"nb = sum(iswet(grd))\nx = ones(nb) # initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"and solve it","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"s = solve(prob, CTKAlg()).u * u\"mol/m^3\"","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"Let's now run some visualizations using the plot recipes. Taking a horizontal slice of the 3D field at 200m gives","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"cmap = :viridis\nplothorizontalslice(s, grd, zunit=u\"μmol/m^3\", depth=200, color=cmap, clim=(0,0.5))","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"and at 500m:","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"plothorizontalslice(s, grd, zunit=u\"μmol/m^3\", depth=500, color=cmap, clim=(0,0.05))","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"Or we can change the timescale and watch the tracer fill the oceans:","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"p = RadioRiversParameters(τ = 50.0u\"yr\")\nprob = SteadyStateProblem(F, ∇ₓF, x, p)\ns_τ50 = solve(prob, CTKAlg()).u * u\"mol/m^3\"\nplothorizontalslice(s_τ50, grd, zunit=u\"μmol/m^3\", depth=500, color=cmap, clim=(0,1))","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"","category":"page"},{"location":"tutorials/5_river_discharge/","page":"River discharge","title":"River discharge","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/2_tracer_transport_operators/#tracer-transport-operators","page":"Tracer transport","title":"Tracer transport","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/#Transport-operator","page":"Tracer transport","title":"Transport operator","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"To model marine biogeochemical tracers on a global scale we need to be able to account for their movement within the 3D ocean. We do this with tracer transport operators, generically denoted by mathcalT. These operators act on a tracer field to give its divergence. In other words, take a tracer with concentration x(boldsymbolr) at location boldsymbolr that is transported by some mechanism represented by the operator mathcalT. Its divergence at boldsymbolr is then (mathcalT x)(boldsymbolr).","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"In the case of the ocean circulation, i.e., the currents and eddies that transport marine tracers floating around in sea water, the transport operator can be represented by","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"mathcalT = nabla cdot left boldsymbolu(boldsymbolr) - mathbfK(boldsymbolr) nabla right","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"The boldsymbolu(boldsymbolr) term represents the mean marine current velocity at location boldsymbolr. Thus, boldsymbolu(boldsymbolr) is a 3D vector aligned with the ocean currents and whose amplitude, in m/s, gives the velocity of the moving sea water. The mathbfK(boldsymbolr) term is a 3×3 matrix that represents eddy diffusivity. That is, it reproduces the effective mixing effect of unresolved eddies, the turbulent vortices that are too small relative to the model grid to be explicitly captured. In earlier models of the ocean circulation, like OCIM's ancestor (denoted OCIM0 in AIBECS), mathbfK was diagonal. Since OCIM1, mathbfK contains non-diagonal to orient mixing preferentially along isopycnals.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"In the case of sinking particles, one can assume that they are only transported downwards with some terminal settling velocity boldsymbolw(boldsymbolr) The corresponding transport operator is then simply","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"mathcalT = nabla cdot boldsymbolw(boldsymbolr)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Discretization","page":"Tracer transport","title":"Discretization","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"In order to represent a marine tracer on a computer one needs to discretize the 3D ocean into a discrete grid, i.e., a grid with a finite number of boxes. One can go a long way towards understanding what a tracer transport operator is by playing with a simple model with only a few boxes, which is the goal of this piece of documentation.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"The simple box model we consider is embedded in a 2×2×2 \"shoebox\". It has 5 wet boxes and 3 dry boxes, as illustrated below:","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"<img src=\"https://user-images.githubusercontent.com/4486578/58314610-3b130b80-7e53-11e9-9fe8-9527cdcca2d0.png\" width =800>","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"An example of discretized advection, boldsymbolu, is shown on the image above, and consists of","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"a meridional overturning circulation flowing in a cycle through boxes 1 → 2 → 6 → 5 → 1 (shown in the meridional section 1 panel)\na zonal current in a reentrant cycling through boxes 1 → 3 → 1 (shown in the layer 1 panel)","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"note: Note\nThis circulation is available as the Primeau_2x2x2 model. You can load it in AIBECS viagrd, T = Primeau_2x2x2.load()Note that this circulation also contains vertical mixing representing deep convection between boxes 2 ↔ 6 (not shown on the image)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Vectorization","page":"Tracer transport","title":"Vectorization","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"In AIBECS, tracers are represented by column vectors. That is, the 3D tracer field, x(boldsymbolr), is vectorized, in the sense that the concentrations in each box are rearranged into a column vector.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"<img src=\"https://user-images.githubusercontent.com/4486578/61757212-fe3ba480-ae02-11e9-8d17-d72866eaafb5.gif\" width =800>","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"The continuous transport operator mathcalT can then be represented by a matrix, denoted by mathbfT, and sometimes called the transport matrix. It turns out that in most cases, this matrix is sparse.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"note: Note\nA sparse matrix behaves the same way as a regular matrix. The only difference is that in a sparse matrix the majority of the entries are zeros. These zeros are not stored explicitly to save computer memory making it possible to deal with fairly high resolution ocean models.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"Mathematically, the discretization and vectorization convert an expression with partial derivatives into a matrix vector product. In summary, for the ocean circulation, we do the following conversion","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"(mathcalT x)(boldsymbolr) = nabla cdot left boldsymbolu(boldsymbolr) - mathbfK(boldsymbolr) nabla right x(boldsymbolr) longrightarrow mathbfT  boldsymbolx","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Ocean-circulations-in-AIBECS","page":"Tracer transport","title":"Ocean circulations in AIBECS","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"In AIBECS, there are currently a few available circulations that you can directly load with the AIBECS:","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"Primeau_2x2x2, the circulation described in this documentation page\nTwoBoxModel, the 2-box model of the Sarmiento and Gruber (2006) book\nArcher_etal_2000, the 3-box model of Archer et al. (2000) (also used in the Sarmiento and Gruber (2006) book)\nOCIM0, the unnamed precursor of the OCIM1 (and which should actually be named OCIM0.1)\nOCIM1\nOCIM2","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"To load any of these, you just need to do","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"grd, T = Circulation.load()","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"where Circulation is one of the circulations listed above.","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"If you are adventurous, you can create your own circulations. AIBECS provides some tools for this. (This is how the Primeau_2x2x2 and Archer_etal_2000 circulations were created.)","category":"page"},{"location":"explanation/2_tracer_transport_operators/#Sinking-particles-in-AIBECS","page":"Tracer transport","title":"Sinking particles in AIBECS","text":"","category":"section"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"There are no loadable transport operators for sinking particles, because there are too many ways to represent sinking particles. However, the AIBECS provides tools to create your own transport operators by providing a scalar or a vector of the downward settling velocities, w. For example, you can create the transport operator for particles sinking at 100 m/d everywhere simply via","category":"page"},{"location":"explanation/2_tracer_transport_operators/","page":"Tracer transport","title":"Tracer transport","text":"T = transportoperator(grd, w=100u\"m/d\")","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/howtos/3_cruiseplot.jl\"","category":"page"},{"location":"howtos/3_cruiseplot/#cruiseplots","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"","category":"section"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This guide follows the basic plotting guide and its goal is to plot data related to oceanographic observations from cruise expeditions. In this walkthrough, we will 1. Create a ficitious cruise track with profile data 2. Plot transects 3. Other plots","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"As in the basic plotting guide, throughout this guide we will use the OCIM2 grid and we will create a dummy modelled tracer.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using AIBECS, Plots\ngrd, _ = OCIM2.load()\nfdummy(lat, lon, depth) = @. cosd(lat) * sind(lon) + sqrt(depth) / 30\ndummy = fdummy(latlondepthvecs(grd)...)","category":"page"},{"location":"howtos/3_cruiseplot/#fictitiouscruise","page":"Plot transect/cruise data","title":"A fictitious cruise","text":"","category":"section"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"For cruise data we use the OceanographyCruises.jl package.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"note: Note\nThe purpose of the OceanographyCruises.jl package is to provide a Julia interface for handling discrete data from cruises. One goal is to use it for, e.g., GEOTRACES data. However here we merely use it to create fictitious cruise data.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Let us create a station Sydney at (34°S, 152°E) and a ALOHA station at (22.75°N, 158°W).","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using OceanographyCruises\nSydney = Station(name=\"Sydney\", lat=-30, lon=156)\nALOHA = Station(name=\"ALOHA\", lat=22.75, lon=-158)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Now let's create a range of 10 stations from Sydney to ALOHA.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Nstations = 10\nstations = range(Sydney, ALOHA, length=Nstations, westmostlon=0)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"(westmostlon=0 ensures that the longitudes are in (0,360) to match the OCIM2 grid we use here.)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"We can now construct a fictitious cruise track","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"ct = CruiseTrack(name=\"CruisyMcCruiseFace\", stations=stations)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"and check the station locations by overlaying a plot of the cruise's track over a surface map of the dummy tracer","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"surfacemap(dummy, grd, color=:grays)\nplotcruisetrack!(ct, markercolor=:red)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Let's create a transect of data that is almost equal to the dummy.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"First, a function for creating random depths","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"function randomdepths(n, max)\n    depths = cumsum(rand(n+1))\n    return max * view(depths,1:n) / maximum(depths)\nend\nNobs = rand(1:20, Nstations) # number of obs per station/profile\ndepths = [randomdepths(Nobs[i], 4000) for i in 1:Nstations]\nobs = [[fdummy(st.lat, st.lon, d) .+ 0.1randn() for d in depths[i]] for (i,st) in enumerate(stations)]\nprofiles = [DepthProfile(station=st, depths=depths[i], values=obs[i]) for (i,st) in enumerate(stations)]\n\nt = Transect(tracer=\"dummy\", cruise=ct.name, profiles=profiles)","category":"page"},{"location":"howtos/3_cruiseplot/#transects","page":"Plot transect/cruise data","title":"Transects","text":"","category":"section"},{"location":"howtos/3_cruiseplot/#Transects","page":"Plot transect/cruise data","title":"Transects","text":"","category":"section"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"We can plot the modelled dummy data along the ct cruise track in the zonal directiion (along longitudes) with","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"plottransect(dummy, grd, ct=ct)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"If we want the observations transect on top of it","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"plotscattertransect!(t)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"If you have the GEOTRACESTools package installed and the GEOTRACES data installed at the right location, you can instead plot real data with something like","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"using GEOTRACESTools\nzonalscattertransect(tracertransect(\"Fe\", \"GA02\"))","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"However, this cannot be showcased online because GEOTRACES decided its data should \"not be distributed to third parties\".","category":"page"},{"location":"howtos/3_cruiseplot/#other-plots","page":"Plot transect/cruise data","title":"Other plots","text":"","category":"section"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"Plots the modelled ratio of two modelled tracers at a given station.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"dummy1 = cosd.(latvec(grd)) + sqrt.(depthvec(grd)) / 30\ndummy2 = cosd.(2latvec(grd)) + 0.5sqrt.(depthvec(grd)) / 30\nratioatstation(dummy1, dummy2, grd, ALOHA, xlabel=\"dummy 1\", ylabel=\"dummy 2\")","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This can be useful to compare stoichiometric ratios at different stations.","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"ratioatstation!(dummy1, dummy2, grd, Sydney, marker=:square)","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"","category":"page"},{"location":"howtos/3_cruiseplot/","page":"Plot transect/cruise data","title":"Plot transect/cruise data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/howtos/2_plot.jl\"","category":"page"},{"location":"howtos/2_plot/#plots","page":"Plot basic things","title":"Plot basic things","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"This guide is organized as follows","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"Horizontal maps\nVertical slices\nDepth profiles","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"In this guide we will focus on how-to plot things using AIBECS' built-in recipes for Plots.jl. These recipes are implemented using RecipesBase.jl, which are explained in Plots.jl's documentation.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"Throughout we will use the OCIM2 grid and we will create a dummy tracer as a function of location to showcase each plot, just for the sake of the examples herein.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"using AIBECS, Plots\ngrd, _ = OCIM2.load()\ndummy = cosd.(latvec(grd))","category":"page"},{"location":"howtos/2_plot/#horizontal-plots","page":"Plot basic things","title":"Horizontal plots","text":"","category":"section"},{"location":"howtos/2_plot/#Horizontal-slice","page":"Plot basic things","title":"Horizontal slice","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"The most common thing you plot after a simulation of marine tracers is a horizontal slice. In this case, you just need to provide the tracer (dummy here), the grid object grd, and the depth at which you want to plot.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plothorizontalslice(dummy, grd, depth=10)","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"You can supply units for the depth at which you want to see the horizontal slice.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plothorizontalslice(dummy, grd, depth=10u\"m\")","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"And the units should be understood under the hood.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plothorizontalslice(dummy, grd, depth=3u\"km\")","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"If your tracer is supplied with units, those will show in the colorbar label","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plothorizontalslice(dummy * u\"mol/m^3\", grd, depth=10u\"m\")","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"The advantage of Plots.jl recipes like this one is that you can specify other pieces of the plot as you would with built-in functions. The advantage of Plots.jl recipes like this one is that you can specify other pieces of the plot as you would with built-in functions. For example, you can chose the colormap with the color keyword argument.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"dummy .*= cosd.(lonvec(grd))\nplt = plothorizontalslice(dummy, grd, depth=100, color=:balance)","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"And you can finetune attributes after the plot is created.","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plot!(plt, xlabel=\"Lon\", ylabel=\"Lat\", colorbar_title=\"dummy value\", title=\"The pacific as a whole\")","category":"page"},{"location":"howtos/2_plot/#vertical-plots","page":"Plot basic things","title":"Vertical plots","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"Exploring the vertical distribution of tracers is important after all.","category":"page"},{"location":"howtos/2_plot/#Zonal-slices","page":"Plot basic things","title":"Zonal slices","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"You must specify the longitude","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"dummy = cosd.(latvec(grd))\ndummy .+= sqrt.(depthvec(grd)) / 30\nplotmeridionalslice(dummy, grd, lon=330)","category":"page"},{"location":"howtos/2_plot/#Zonal-averages","page":"Plot basic things","title":"Zonal averages","text":"","category":"section"},{"location":"howtos/2_plot/#Global-zonal-average","page":"Plot basic things","title":"Global zonal average","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"zonalaverage(dummy, grd)","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"If you want a zonal average over a specific region, you can just mask it out","category":"page"},{"location":"howtos/2_plot/#Basin-zonal-average","page":"Plot basic things","title":"Basin zonal average","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"This is experimental at this stage and relies on OceanBasins.jl. You can create basin masks using this package with","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"using OceanBasins\nOCEANS = oceanpolygons()\nbasins = sum(i*isbasin(latvec(grd), lonvec(grd), OCEANS) for (i,isbasin) in enumerate([isindian2, ispacific2, isatlantic2, isantarctic]))\nsurfacemap(basins, grd, seriestype=:heatmap, color=:lightrainbow)","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"and you can mask a specific region with the mask keyword argument","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"mPAC = ispacific(latvec(grd), lonvec(grd), OCEANS)\nplotzonalaverage(dummy, grd, mask=mPAC)","category":"page"},{"location":"howtos/2_plot/#Meridional-slices","page":"Plot basic things","title":"Meridional slices","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"Just as you should expect at this stage, you can plot a meridional slice with","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plotmeridionalslice(dummy, grd, lon=-30)","category":"page"},{"location":"howtos/2_plot/#profile-plots","page":"Plot basic things","title":"Depth profiles","text":"","category":"section"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"Sometimes you want a profile at a given station or location","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"plotdepthprofile(dummy, grd, lonlat=(-30,30))","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"","category":"page"},{"location":"howtos/2_plot/","page":"Plot basic things","title":"Plot basic things","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/howtos/4_fluxes.jl\"","category":"page"},{"location":"howtos/4_fluxes/#fluxes","page":"Estimate fluxes","title":"Estimate fluxes","text":"","category":"section"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"This will take you through the process of extracting flux information from a given transport operator. It is split into 3 parts","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Figure out the stencil of the operator\nPartition the operator according to said stencil\nEstimate the flux of a given 3D tracer field","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Let's start telling Julia we will be using AIBECS and Plots.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"using AIBECS, Plots","category":"page"},{"location":"howtos/4_fluxes/#operatorstencil","page":"Estimate fluxes","title":"1. Operator stencil","text":"","category":"section"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Let's load the OCCA grid information grd and transport matrix mathbfT (the variable T here).","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"grd, T = OCCA.load()","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Multiplying mathbfT with a given tracer concentration vector boldsymbolx gives the flux-divergence of that tracer. In other words, mathbfT operates on boldsymbolx by exchanging tracers between model-grid boxes. But mathbfT only operates on neighboring grid boxes. I.e., mathbfT usually does not directly exchange tracers between boxes far away from each other.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"AIBECS provides a function, stencil, that returns all the relative cartesian indices (AKA the relative sub-indices) of the neighbors used by a given operator. In the case of OCCA, the stencil is thus","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"st = stencil(T, grd)","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"There is also a label function to, well, label the stencil elements in a more human-readable way. (Note label is not exported, so you must specify that it comes from the AIBECS package, as below.)","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"[st AIBECS.label.(st)]","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"The stencil can be visualized with the plotstencil recipe","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"plotstencil(st)","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"note: Note\nThe continuous equivalent of the matrix mathbfT, i.e., the flux-divergence operator mathcalT, is a differential operator, which is local by definition. It is the spatial discretization of the differential operators that imposes the use of neighboring boxes to estimate spatial gradients.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"This works for any circulation, so you can swap grd and T and try again... Here we plot the same figure for a few different circulations available in AIBECS.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"plts = Any[]\nfor Circulation in [OCIM0, OCIM1, OCIM2, OCCA]\n    grd, T = Circulation.load()\n    push!(plts, plotstencil(stencil(grd, T), title=string(Circulation)))\nend\nplot(plts..., layout=(2,2))","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"These stencils are useful to clarify the origin and destination of tracer fluxes we are going to explore in this guide..","category":"page"},{"location":"howtos/4_fluxes/#operatorpartition","page":"Estimate fluxes","title":"2. Operator Partition","text":"","category":"section"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"For a given operator mathbfT, to each point (or neighbor) k in its stencil corresponds a unique transport operator mathbfT_k, which effectively performs the transfer of tracers from that neighbor. In other words, if the stencil has n elements, mathbfT can be partitionned into a family of n-1 matrices mathbfT_k that each operate in a single direction of the stencil.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Let's take the \"West\" neighbor of the OCCA stencil","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"dir = st[findfirst(AIBECS.label.(st) .== \"West\")]","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"The AIBECS provides a function directional_T that returns the transport operator corresponding to the direction provided from the stencil element.","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"T_West = directional_transport(T, grd, dir)","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"Notice how T_West only has nonzeros on the main diagonal and on one off-diagonal, that connect each box index with the index of the box \"West\" of it.","category":"page"},{"location":"howtos/4_fluxes/#fluxestimate","page":"Estimate fluxes","title":"3. Flux Estimate","text":"","category":"section"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"We can look at the depth-integrated mean flux of a fictitious tracer boldsymbolx of concentration 1 mol m⁻³ coming from the west by computing and plotting the vertical integral of -mathbfTboldsymbolx:","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"nwet = count(iswet(grd))\nx = ones(nwet)\nplotverticalintegral(-T_West * x * u\"mol/m^3/s\" .|> u\"μmol/m^3/s\", grd, mask=depthvec(grd) .< 100, color=:seaborn_icefire_gradient, clim=1e2 .* (-1,1))","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"warning: Warning\nThis guide is still a work in progress and likely contains errors","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"","category":"page"},{"location":"howtos/4_fluxes/","page":"Estimate fluxes","title":"Estimate fluxes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/functions/#AIBECS-functions","page":"AIBECS functions","title":"AIBECS functions","text":"","category":"section"},{"location":"reference/functions/#Circulations","page":"AIBECS functions","title":"Circulations","text":"","category":"section"},{"location":"reference/functions/","page":"AIBECS functions","title":"AIBECS functions","text":"OCIM2.load\nOCIM1.load\nOCIM0.load\nOCCA.load\nPrimeau_2x2x2.load\nArcher_etal_2000.load\nTwoBoxModel.load","category":"page"},{"location":"reference/functions/#AIBECS.OCIM2.load","page":"AIBECS functions","title":"AIBECS.OCIM2.load","text":"load\n\nReturns the grid, the transport matrix, and the He fluxes (in that order).\n\ntip: Tip\nTo load the default OCIM2 matrix and grid, dojulia> grd, T = OCIM2.load()But you can also load the other matrices by specifying which version you want, e.g.,julia> grd, T = OCIM2.load(version=\"KiHIGH_noHe\")See DeVries and Holzer (2019) for more details\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.OCIM1.load","page":"AIBECS functions","title":"AIBECS.OCIM1.load","text":"load\n\nReturns the grid and the transport matrix (in that order).\n\nUsage\n\njulia> grd, T = OCIM1.load()\n\nSee DeVries and Primeau (2011) and DeVries (2014) for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.OCIM0.load","page":"AIBECS functions","title":"AIBECS.OCIM0.load","text":"load\n\nReturns the grid and the transport matrix (in that order).\n\nUsage\n\njulia> grd, T = OCIM0.load()\n\nSee DeVries and Primeau (2011) and Primeau et al. (2013) for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.OCCA.load","page":"AIBECS functions","title":"AIBECS.OCCA.load","text":"load\n\nReturns the grid and the transport matrix.\n\ntip: Tip\nTo load the OCCA matrix and grid, dojulia> grd, T = OCCA.load()See Forget (2010) for more details\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.Primeau_2x2x2.load","page":"AIBECS functions","title":"AIBECS.Primeau_2x2x2.load","text":"load\n\nReturns grd and T (in that order).\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.Archer_etal_2000.load","page":"AIBECS functions","title":"AIBECS.Archer_etal_2000.load","text":"load\n\nReturns grd and T (in that order).\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.TwoBoxModel.load","page":"AIBECS functions","title":"AIBECS.TwoBoxModel.load","text":"load\n\nReturns grd and T (in that order).\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Plotting","page":"AIBECS functions","title":"Plotting","text":"","category":"section"},{"location":"reference/functions/","page":"AIBECS functions","title":"AIBECS functions","text":"plothorizontalslice\nsurfacemap\nplot∫dz\nplotverticalmean\nminimap\nplotmeridionalslice\nplotzonalmean\nplot∫dx\nplotzonalslice\nplotmeridionalmean\nplot∫dy\nplot∫dxdy\nplothorizontalmean\nplotdepthprofile\nplottransect\nratioatstation\nplotparameter\nplotparameters","category":"page"},{"location":"reference/functions/#AIBECS.plothorizontalslice","page":"AIBECS functions","title":"AIBECS.plothorizontalslice","text":"plothorizontalslice(x, grd; depth)\n\nPlots a heatmap of the horizontal slice of tracer x at depth depth.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.surfacemap","page":"AIBECS functions","title":"AIBECS.surfacemap","text":"surfacemap(x, grd)\n\nPlots a surface heatmap of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plot∫dz","page":"AIBECS functions","title":"AIBECS.plot∫dz","text":"plotverticalintegral(x, grd, mask=1)\n\nPlots the vertical integral of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotverticalmean","page":"AIBECS functions","title":"AIBECS.plotverticalmean","text":"plotverticalaverage(x, grd, mask=1)\n\nPlots the vertical average of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.minimap","page":"AIBECS functions","title":"AIBECS.minimap","text":"minimap(grd; central_longitude=200°)\n\nPlots a surface map of grd with no ticks, labels, or colorbar.\n\nThe goal of this function is to provide a way to plot both a minimap and a cruise track when plotting a transect:\n\nplottransect(dummy, grd; ct=sort(ct))\nplot!(inset_subplots=bbox(0.73,0.73,0.15,0.15), subplot=2)\nminimap!(grd; subplot=2)\ncruisetrackplots!(sort(ct), subplot=2)\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotmeridionalslice","page":"AIBECS functions","title":"AIBECS.plotmeridionalslice","text":"plotmeridionalslice(x, grd; lon)\n\nPlots a meridional slice of tracer x at longitude lon.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotzonalmean","page":"AIBECS functions","title":"AIBECS.plotzonalmean","text":"plotzonalmean(x, grd; mask=1)\n\nPlots a zonal average of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plot∫dx","page":"AIBECS functions","title":"AIBECS.plot∫dx","text":"plotzonalintegral(x, grd; mask=1)\n\nPlots a zonal integral of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotzonalslice","page":"AIBECS functions","title":"AIBECS.plotzonalslice","text":"plotzonalslice(x, grd; lat)\n\nPlots a zonal slice of tracer x at latitude lat.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotmeridionalmean","page":"AIBECS functions","title":"AIBECS.plotmeridionalmean","text":"plotmeridionalmean(x, grd; mask=1)\n\nPlots a meridional average of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plot∫dy","page":"AIBECS functions","title":"AIBECS.plot∫dy","text":"plotmeridionalintegral(x, grd; mask=1)\n\nPlots a meridional integral of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plot∫dxdy","page":"AIBECS functions","title":"AIBECS.plot∫dxdy","text":"horizontalintegral(x, grd; mask=1)\n\nPlots a horizontal integral of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plothorizontalmean","page":"AIBECS functions","title":"AIBECS.plothorizontalmean","text":"plothorizontalaverage(x, grd; mask=1)\n\nPlots a horizontal average of tracer x.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotdepthprofile","page":"AIBECS functions","title":"AIBECS.plotdepthprofile","text":"plotdepthprofile(x, grd; lonlat)\n\nPlots the profile of tracer x interpolated at lonlat=(x,y) coordinates.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plottransect","page":"AIBECS functions","title":"AIBECS.plottransect","text":"plottransect(x, grd; ct=ct)\n\nPlots the transect of tracer x along transect ct.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.ratioatstation","page":"AIBECS functions","title":"AIBECS.ratioatstation","text":"RatioAtStation(x, y, grd, station, depthlims=(0,Inf))\n\nPlots a meridional transect of tracer x along cruise track ct.\n\nThe keyword argument zlims=(ztop, zbottom) can be provided if you only want to only plot for depths z ∈ (ztop, zbottom). (z is positive downwards in this case)\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotparameter","page":"AIBECS functions","title":"AIBECS.plotparameter","text":"PlotParameter(p::AbstractParameters, s)\n\nPlots the PDF of parameter p with symbol s\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.plotparameters","page":"AIBECS functions","title":"AIBECS.plotparameters","text":"PlotParameters(p::AbstractParameters)\n\nPlots the PDF of all the flattenable parameters in p.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Parameters","page":"AIBECS functions","title":"Parameters","text":"","category":"section"},{"location":"reference/functions/","page":"AIBECS functions","title":"AIBECS functions","text":"AbstractParameters\nunpack\nlength(<:AbstractParameters)\nsize(<:AbstractParameters)\nvalues(<:AbstractParameters)\nsymbols\nflattenable_values\nflattenable_symbols\nlatex\ntable\nvec","category":"page"},{"location":"reference/functions/#AIBECS.AbstractParameters","page":"AIBECS functions","title":"AIBECS.AbstractParameters","text":"AbstractParameters{T} <: AbstractVector{T}\n\nAn abstract type for AIBECS model parameters.\n\nParameters in AIBECS use the following convenience packages:\n\nParameters\nFieldMetadata\nFieldDefaults\nFlatten\nUnitful\nDataFrames\nDistributions\n\nThese aim to allow for some nice features, which include\n\nnice syntax for unpacking parameters in functions via the @unpack macro (fron UnPack.jl)\nadditional metadata on parameters\neasy conversion to and from vectors\nuse of units and automatic conversions if necessary\npretty table-format displays\nloading and saving to and from CSV files\nprior estimates for bayesian inference and optimization\n\nSee the list of examples to get an idea of how to generate parameters for your model.\n\nExamples\n\nGenerate a simple parameter type via\n\njulia> struct SimpleParams{T} <: AbstractParameters{T}\n           α::T\n           β::T\n           γ::T\n       end\nSimpleParams\n\nTo create an instance of the SimpleParams(Float64) type, you can do\n\njulia> p = SimpleParams(1.0, 2.0, 3.0)\nSimpleParams{Float64}\n│ Row │ Symbol │ Value   │\n│     │ Symbol │ Float64 │\n├─────┼────────┼─────────┤\n│ 1   │ α      │ 1.0     │\n│ 2   │ β      │ 2.0     │\n│ 3   │ γ      │ 3.0     │\n\nOne of the core features from Parameters is unpacking in functions, e.g.,\n\njulia> function simplef(p)\n           @unpack α, γ = p\n           return α + γ\n       end\nsimplef (generic function with 1 method)\n\njulia> simplef(p) # 1.0 + 3.0\n4.0\n\nMore complex examples are permitted by adding metadata (thanks to FieldMetadata.jl). You can add units\n\njulia> @units struct UnitParams{T} <: AbstractParameters{T}\n           α::T | u\"km\"\n           β::T | u\"hr\"\n           γ::T | u\"m/s\"\n       end ;\n\njulia> p = UnitParams(1.0, 2.0, 3.0)\nUnitParams{Float64}\n│ Row │ Symbol │ Value   │ Unit     │\n│     │ Symbol │ Float64 │ Unitful… │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ α      │ 1.0     │ km       │\n│ 2   │ β      │ 2.0     │ hr       │\n│ 3   │ γ      │ 3.0     │ m s^-1   │\n\nNote that when adding units to your parameters, they will be converted to SI when unpacked, as in, e.g.,\n\njulia> function speed(p)\n           @unpack α, β, γ = p\n           return α / β + γ\n       end\nspeed (generic function with 1 method)\n\njulia> speed(p) # (1.0 km / 2.0 hr + 3 m/s) in m/s\n3.138888888888889\n\nAnother example for optimizable/flattenable parameters\n\njulia> @initial_value @units @flattenable struct OptParams{T} <: AbstractParameters{T}\n           α::T | 3.6 | u\"km\"  | true\n           β::T | 1.0 | u\"hr\"  | false\n           γ::T | 1.0 | u\"m/s\" | true\n       end ;\n\njulia> p = OptParams(initial_value(OptParams)...)\nOptParams{Float64}\n│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Optimizable │\n│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Bool        │\n├─────┼────────┼─────────┼───────────────┼──────────┼─────────────┤\n│ 1   │ α      │ 3.6     │ 3.6           │ km       │ 1           │\n│ 2   │ β      │ 1.0     │ 1.0           │ hr       │ 0           │\n│ 3   │ γ      │ 1.0     │ 1.0           │ m s^-1   │ 1           │\n\nThanks to the FieldMetaData interface, you can chain the following preloaded metadata:\n\ninitial_value\nunits (from Unitful.jl)\nprior (from Distributions.jl)\ndescription (String)\nbounds (2-element Tuple)\nlogscaled (Bool)\nflattenable (to convert to vectors of optimizable parameters only)\nreference (String)\n\nHere is an example of parameter with all the possible metadata available in AIBECS:\n\njulia> @initial_value @units @prior @description @bounds @logscaled @flattenable @reference struct FullParams{T} <: AbstractParameters{T}\n           α::T | 1.0 | u\"km\"  | Normal(0,1)    | \"The distance\"   | (-Inf, Inf) | false | false | \"Jean et al., 2042\"\n           β::T | 2.0 | u\"hr\"  | LogNormal(0,1) | \"The time\"       | (   0, Inf) | true  | true  | \"Claude et al. 1983\"\n           γ::T | 3.0 | u\"mol\" | Normal(1,2)    | \"The # of moles\" | (  -1,   1) | false | true  | \"Dusse et al. 2000\"\n       end ;\n\njulia> FullParams(4.0, 5.0, 6.0)\nFullParams{Float64}\n│ Row │ Symbol │ Value   │ Initial value │ Unit     │ Prior                            │ Description    │ Bounds      │ Logscaled │ Optimizable │ Reference          │\n│     │ Symbol │ Float64 │ Float64       │ Unitful… │ Distribu…                        │ String         │ Tuple…      │ Bool      │ Bool        │ String             │\n├─────┼────────┼─────────┼───────────────┼──────────┼──────────────────────────────────┼────────────────┼─────────────┼───────────┼─────────────┼────────────────────┤\n│ 1   │ α      │ 4.0     │ 1.0           │ km       │ Normal{Float64}(μ=0.0, σ=1.0)    │ The distance   │ (-Inf, Inf) │ 0         │ 0           │ Jean et al., 2042  │\n│ 2   │ β      │ 5.0     │ 2.0           │ hr       │ LogNormal{Float64}(μ=0.0, σ=1.0) │ The time       │ (0, Inf)    │ 1         │ 1           │ Claude et al. 1983 │\n│ 3   │ γ      │ 6.0     │ 3.0           │ mol      │ Normal{Float64}(μ=1.0, σ=2.0)    │ The # of moles │ (-1, 1)     │ 0         │ 1           │ Dusse et al. 2000  │\n\nNote that there is no check that the metadata you give is consistent. These metadata will hopefully be useful for advanced usage of AIBECS, e.g., using prior information and/or bounds for optimization.\n\n\n\n\n\n","category":"type"},{"location":"reference/functions/#AIBECS.latex","page":"AIBECS functions","title":"AIBECS.latex","text":"latex(p)\n\nReturns a LaTeX-formatted table of the parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#Base.vec","page":"AIBECS functions","title":"Base.vec","text":"vec(p::T) where {T <: AbstractParameters}\n\nReturns a SI-unit-converted vector of flattenable values of p.\n\nNote that vec(p) ≠ flattenable_values(p) if p has units.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#For-simulations","page":"AIBECS functions","title":"For simulations","text":"","category":"section"},{"location":"reference/functions/","page":"AIBECS functions","title":"AIBECS functions","text":"state_function_and_Jacobian\nsplit_state_function_and_Jacobian\nSteadyStateProblem\nsolve","category":"page"},{"location":"reference/functions/#AIBECS.state_function_and_Jacobian","page":"AIBECS functions","title":"AIBECS.state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#AIBECS.split_state_function_and_Jacobian","page":"AIBECS functions","title":"AIBECS.split_state_function_and_Jacobian","text":"F, ∇ₓF = state_function_and_Jacobian(Ts, Gs, nb)\n\nReturns the state function F and its jacobian, ∇ₓF.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#DiffEqBase.SteadyStateProblem","page":"AIBECS functions","title":"DiffEqBase.SteadyStateProblem","text":"SteadyStateProblem(F, ∇ₓF, x, p)\n\nReturns the SteadyStateProblem defined by F(x,p)=0.\n\n\n\n\n\n","category":"type"},{"location":"reference/functions/#DiffEqBase.solve","page":"AIBECS functions","title":"DiffEqBase.solve","text":"solve(prob::DiffEqBase.AbstractSteadyStateProblem,\n      alg::CTKAlg;\n      nrm=norm,\n      τstop=1e12*365*24*60*60,\n      preprint=\"\",\n      maxItNewton=50)\n\nSolves prob using the modified C.T.Kelley Shamanskii algorithm.\n\n\n\n\n\n","category":"function"},{"location":"reference/functions/#For-optimization","page":"AIBECS functions","title":"For optimization","text":"","category":"section"},{"location":"reference/functions/","page":"AIBECS functions","title":"AIBECS functions","text":"mismatch\n∇mismatch","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/tutorials/1_ideal_age.jl\"","category":"page"},{"location":"tutorials/1_ideal_age/#ideal-age","page":"Ideal age","title":"Ideal age","text":"","category":"section"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"note: Note\nAll the AIBECS tutorials and how-to guides are available as Jupyter notebooks. You can execute them online with binder or just view them with nbviewer by clicking on the badges above!","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"The tracer equation for the ideal age is","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"left(partial_t + mathbfTright) boldsymbola = 1 - fracboldsymbolaτ  (boldsymbolz le z_0)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"where the sink term on the right clamps the age to 0 at the surface (where boldsymbolz le z_0). The smaller the timescale tau, the quicker boldsymbola is restored to 0 at the surface.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"AIBECS can interpret tracer equations as long as you arrange them under the generic form:","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"big(partial_t + mathbfT(boldsymbolp) big) boldsymbolx = boldsymbolG(boldsymbolx boldsymbolp)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"where mathbfT(boldsymbolp) is the transport, boldsymbolG(boldsymbolx boldsymbolp) is the net local sources and sinks, and boldsymbolp is the vector of model parameters. We will then use the AIBECS to simulate the ideal age by finding the steady-state of the system, i.e., the solution of","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"partial_t boldsymbolx = boldsymbolF(boldsymbolx boldsymbolp) = boldsymbolG(boldsymbolx boldsymbolp) - mathbfT(boldsymbolp)  boldsymbolx = 0","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"In this tutorial, we will simulate the ideal age by","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"defining functions for T(p) and G(x,p),\ndefining the parameters p,\ngenerating the state function F(x,p) and solving the associated steady-state problem,\nand finally making a plot of our simulated ideal age.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"We start by telling Julia that we want to use the AIBECS package and the OCIM2 circulation (the Ocean Circulation Inverse Model[1]).","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"[1]: DeVries, T., & Holzer, M. (2019). Radiocarbon and helium isotope constraints on deep ocean ventilation and mantle‐³He sources. Journal of Geophysical Research: Oceans, 124, 3036–3057. doi:10.1029/2018JC014716","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"using AIBECS\ngrd, TOCIM2 = OCIM2.load()","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"note: Note\nIf it's your first time, Julia will ask you to download the OCIM2, in which case you should accept (i.e., type y and \"return\"). Once downloaded, AIBECS will remember where it downloaded the file and it will only load it from your laptop.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"grd is an OceanGrid object containing information about the 3D grid of the OCIM2 circulation and TOCIM2 is the transport matrix representing advection and diffusion.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"We define the function T(p) as","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"T(p) = TOCIM2","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"(It turns out the circulation T(p) does not effectively depend on p but that's how we must define it anyway, i.e., as a function of p.)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"The local sources and sinks for the age take the form","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"function G(x,p)\n    @unpack τ, z₀ = p\n    return @. 1 - x / τ * (z ≤ z₀)\nend","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"as per the tracer equation. The @unpack line unpacks the parameters τ and z₀. The return line returns the net sources and sinks. (The @. \"macro\" tells Julia that the operations apply to every element.)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"We can define the vector z of depths with depthvec.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"z = depthvec(grd)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"Now we must construct a type for p the parameters. This type must contain our parameters τ and z₀.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"struct IdealAgeParameters{U} <: AbstractParameters{U}\n    τ::U\n    z₀::U\nend","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"The type is now ready for us to generate an instance of the parameter p. Let's use τ = 1.0 (s) and z₀ the minimum depth of the model.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"p = IdealAgeParameters(1.0, 30.0)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"We now use the AIBECS to generate the state function boldsymbolF (and its Jacobian) via","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"F, ∇ₓF = state_function_and_Jacobian(T, G)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"(∇ₓF is the Jacobian of the state function nabla_boldsymbolxboldsymbolF, calculated automatically using dual numbers.)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"Now that F(x,p), and p are defined, we are going to solve for the steady-state. But first, we must create a SteadyStateProblem object that contains F, ∇ₓF, p, and an initial guess x_init for the age. (SteadyStateProblem is specialized from DiffEqBase for AIBECS models.)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"Let's make a vector of 0's for our initial guess.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"nb = sum(iswet(grd))  # number of wet boxes\nx_init = zeros(nb)    # Start with age = 0 everywhere","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"Now we can create our SteadyStateProblem instance","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"prob = SteadyStateProblem(F, ∇ₓF, x_init, p)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"And finally, we can solve this problem, using the AIBECS CTKAlg() algorithm,","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"age = solve(prob, CTKAlg())","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"This should take a few seconds.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"To conclude this tutorial, let's have a look at the age using AIBECS' plotting recipes and Plots.jl.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"using Plots","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"We first convert the age in years (because the default SI unit we used, i.e., seconds, is a bit small relative to global ocean timescales).","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"age_in_yrs = age * u\"s\" .|> u\"yr\"","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"And we take a horizontal slice at about 2000m.","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"plothorizontalslice(age_in_yrs, grd, depth=2000u\"m\", color=:magma)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"Or look at the horiontal mean","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"plothorizontalmean(age_in_yrs, grd)","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"That's it for this tutorial... Good job!","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"","category":"page"},{"location":"tutorials/1_ideal_age/","page":"Ideal age","title":"Ideal age","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/tutorials/3_Pmodel.jl\"","category":"page"},{"location":"tutorials/3_Pmodel/#P-model","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"","category":"section"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"In this tutorial we will explicitly simulate 2 tracers whose distributions control and feed back on each other.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We consider a simple model for the cycling of phosphorus with 2 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP) and particulate organic phosphorus (POP). The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The governing equations that couple the 3D concentration fields of DIP and POP, denoted x_mathsfDIP and x_mathsfPOP, respectively, are:","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"leftfracpartialpartial t + nabla cdot (boldsymbolu + mathbfKnabla )right x_mathsfDIP = -U(x_mathsfDIP) + R(x_mathsfPOP)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"and","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"leftfracpartialpartial t + nabla cdot boldsymbolwright x_mathsfPOP = U(x_mathsfDIP) - R(x_mathsfPOP)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The nabla cdot left boldsymbolu - mathbfK nabla right and nabla cdot boldsymbolw operators represent the ocean circulation and the sinking of particles, respectively. (Tracer transport operators are described in the documentation.)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The function U represents the biological uptake of DIP by phytoplankton, which we model here as","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"U(x_mathsfDIP) = fracx_mathsfDIPtau_mathsfDIP  fracx_mathsfDIPx_mathsfDIP + k  (z  z_0)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"with the timescale, tau, the half-saturation rate k, and the depth z_0 as parameters.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"The function R defines the remineralization rate of POP, which converts POP back into DIP. For the remineralization, we simply use a linear rate constant, i.e.,","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"R(x_mathsfPOP) = fracx_mathsfPOPtau_mathsfPOP","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We start by telling Julia we want to use the AIBECS and the OCIM0.1 circulation for DIP.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"using AIBECS\ngrd, T_OCIM = OCIM0.load()\nT_DIP(p) = T_OCIM","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the sinking of particles, we use the transportoperator function","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"T_POP(p) = transportoperator(grd, z -> w(z,p))","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"for which we need to define the sinking speed w(z,p) as a function of depth z and of the parameters p. Following the assumption that w(z) = w_0 + w z increases linearly with depth, we write it as","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function w(z,p)\n    @unpack w₀, w′ = p\n    return @. w₀ + w′ * z\nend","category":"page"},{"location":"tutorials/3_Pmodel/#Uptake-(DIP-POP)","page":"A coupled PO₄–POP model","title":"Uptake (DIP → POP)","text":"","category":"section"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the uptake, U, we write","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"z = depthvec(grd)\nfunction U(x,p)\n    @unpack τ_DIP, k, z₀ = p\n    return @. x/τ_DIP * x/(x+k) * (z≤z₀) * (x≥0)\nend","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"where we have \"unpacked\" the parameters to make the code clearer and as close to the mathematical equation as possible. (Note we have also added a constraint that x must be positive for uptake to happen.)","category":"page"},{"location":"tutorials/3_Pmodel/#Remineralization-(POP-DIP)","page":"A coupled PO₄–POP model","title":"Remineralization (POP → DIP)","text":"","category":"section"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"For the remineralization, R, we write","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function R(x,p)\n    @unpack τ_POP = p\n    return x / τ_POP\nend","category":"page"},{"location":"tutorials/3_Pmodel/#Net-sources-and-sinks","page":"A coupled PO₄–POP model","title":"Net sources and sinks","text":"","category":"section"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We lump the sources and sinks into G functions for DIP and POP.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"function G_DIP(DIP, POP, p)\n    @unpack DIP_geo, τ_geo = p\n    return @. -$U(DIP,p) + $R(POP,p) + (DIP_geo - DIP) / τ_geo\nend\nfunction G_POP(DIP, POP, p)\n    @unpack τ_geo = p\n    return @. $U(DIP,p) - $R(POP,p) - POP / τ_geo\nend","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"where we have imposed a slow restoring of DIP to the global mean DIP_geo to prescribe the global mean concentration. (The $ signs in front of U and R protect them from the broadcast macro @.)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We now define and build the parameters.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"In this tutorial we will specify some initial values for the parameters and also include units.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"import AIBECS: @units, units\nimport AIBECS: @initial_value, initial_value\nusing Unitful: m, d, s, yr, Myr, mol, mmol, μmol, μM\n@initial_value @units struct PmodelParameters{U} <: AbstractParameters{U}\n    w₀::U       |  0.64 | m/d\n    w′::U       |  0.13 | m/d/m\n    τ_DIP::U    | 230.0 | d\n    k::U        |  6.62 | μmol/m^3\n    z₀::U       |  80.0 | m\n    τ_POP::U    |   5.0 | d\n    τ_geo::U    |   1.0 | Myr\n    DIP_geo::U  |  2.12 | mmol/m^3\nend","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Finally, thanks to the initial values we provided, we can instantiate the parameter vector succintly as","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"p = PmodelParameters()","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We generate the state function F and its Jacobian ∇ₓF,","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"nb = sum(iswet(grd))\nF, ∇ₓF = state_function_and_Jacobian((T_DIP, T_POP), (G_DIP, G_POP), nb)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"generate the steady-state problem,","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"@unpack DIP_geo = p\nx = DIP_geo * ones(2nb) # initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"and solve it","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"sol = solve(prob, CTKAlg()).u","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We can look at different the DIP and POP fields using the Plots.jl recipes.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"DIP, POP = state_to_tracers(sol, grd) # unpack tracers","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"First, let's look at the mean profile","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"using Plots\nplothorizontalmean(DIP * (mol/m^3) .|> μM, grd)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"We can plot the concentration of DIP at a given depth via, e.g.,","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"plothorizontalslice(DIP * (mol/m^3) .|> μM, grd, depth=1000m, color=:viridis)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Or have a look at a map of the uptake at the surface","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"plotverticalintegral(U(DIP,p) * (mol/m^3/s) .|> mmol/yr/m^3, grd, color=:algae)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Or look at what is exported below 500 m","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"plothorizontalslice(POP .* w(z,p) * (mol/m^3*m/s) .|> mmol/yr/m^2, grd, depth=500m, color=:inferno, rev=true)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Now let's make our model a little fancier and use a fine topographic map to refine the remineralization profile. For this, we will use the ETOPO dataset, which can be downloaded by AIBECS via","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"f_topo = ETOPO.fractiontopo(grd)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"f_topo is the fraction of sediments located in each wet box of the grd grid. We can use it to redefine the transport operator for sinking particles to take into consideration the subgrid topography, such that the fine-resolution sediments intercept settling POP.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"T_POP2(p) = transportoperator(grd, z -> w(z,p); frac_seafloor=f_topo)","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"With this new vertical transport for POP, we can recreate our problem, solve it again","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"F2, ∇ₓF2 = state_function_and_Jacobian((T_DIP, T_POP2), (G_DIP, G_POP), nb)\nprob2 = SteadyStateProblem(F2, ∇ₓF2, x, p)\nsol2 = solve(prob2, CTKAlg()).u\nDIP2, POP2 = state_to_tracers(sol2, grd) # unpack tracers","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"and check the difference","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"plotzonalaverage((DIP2 - DIP) ./ DIP .|> u\"percent\", grd, color=:balance, clim=(-0.1, 0.1))","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"This zonal average shows how much DIP is prevented from sinking out of the surface layers with the new subgrid parameterization.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"Let's look at the vertical average.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"plotverticalaverage((DIP2 - DIP) ./ DIP .|> u\"percent\", grd, color=:balance, clim=(-0.1,0.1))","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"This shows minor changes, on the order of 0.1%, on the global scale, which means that the subgrid-topography parameterization mostly affects the vertical distribution of our tracers.","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"","category":"page"},{"location":"tutorials/3_Pmodel/","page":"A coupled PO₄–POP model","title":"A coupled PO₄–POP model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/tutorials/4_dustmodel.jl\"","category":"page"},{"location":"tutorials/4_dustmodel/#dust-model","page":"A dust model","title":"A dust model","text":"","category":"section"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"In this tutorial we will simulate particles of dust that graviationally settle. 2D maps of dust deposition are available from within the AIBECS. To use these, we will convert them into sources in the top layer of the model grid. Once \"born\", depending on the settling velocity, these dust particles can spread horizontally until they eventually reach the sea floor and are buried in the sediments.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"The governing equation of the 3D concentration field of dust, denoted x_mathsfdust, is:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"leftfracpartialpartial t + nabla cdot (boldsymbolu + boldsymbolw + mathbfKnabla)right x_mathsfdust = s_mathsfdust","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"where nabla cdot left boldsymbolu - mathbfK nabla right and nabla cdot boldsymbolw represent the ocean circulation transport and the vertical settling of dust particles, respectively. (Tracer transport operators are described in the documentation.) The only source term, s_mathsfdust, is the dust deposition.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"In AIBECS, we must recast this equation in the generic form","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"leftfracpartialpartial t + mathbfT(boldsymbolp)right boldsymbolx = boldsymbolG(boldsymbolxboldsymbolp)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"We start by telling Julia we want to use the AIBECS and the OCIM0.1 transport matrix for the ocean circulation.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"using AIBECS\ngrd, T_OCIM = OCIM0.load()","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"The transport of dust is the sum of the ocean circulation and a settling-transport:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"function T_dust(p)\n    @unpack fsedremin = p\n    return T_OCIM + transportoperator(grd, z -> w(z,p), fsedremin=fsedremin)\nend","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"For the settling transport of dust particles, we have used the transportoperator function for which we need to define the settling velocity w(z,p) as a function of depth z and of the parameters p.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"note: Note\nWe have imposed a fsedremin remineralization at the sediment with its keyword argument. (Default is fsedremin=1.0.) This turns the settling transport into a sink that removes all the dust reaching the sea floor.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Following the assumption that w(z) = w_0 + w z increases linearly with depth, we write it as","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"function w(z,p)\n    @unpack w₀, w′ = p\n    return @. w₀ + w′ * z\nend\nz = depthvec(grd)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"The parameters fsedremin, w₀, and w′ will be defined shortly.","category":"page"},{"location":"tutorials/4_dustmodel/#Dust-depositon","page":"A dust model","title":"Dust depositon","text":"","category":"section"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"The AIBECS allows you to use climatological dust deposition fields from the Mahowald lab.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s_A_2D = AeolianSources.load()","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"First, we must regrid these 2D maps onto the surface layer of grd, the 3D grid of the ocean circulation. To do that, we interpolate the 2D map of dust deposition onto the ocean grid's lat and lon:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s_dust_2D_monthly = s_A_2D[:Dust] # kg m⁻² s⁻¹\ns_dust_2D_annual = permutedims(dropdims(sum(s_dust_2D_monthly, dims=3), dims=3), (2,1)) / 12\ns_dust_2D = regrid(s_dust_2D_annual, s_A_2D[:lat], s_A_2D[:lon], grd)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"(This required a bit of work to reshape s_dust_2D_annual before using regrid.)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Then we create a blank 3D array of zeros, of which we paint the top layer:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s_dust_3D = zeros(size(grd)...)\ns_dust_3D[:,:,1] .= s_dust_2D","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"we convert it to a SI volumetric unit (i.e., in g m⁻³)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s_dust_3D = ustrip.(upreferred.(s_dust_3D * u\"kg/m^2/s\" ./ grd.δz_3D))","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Finally, we vectorize it via","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s_dust = vectorize(s_dust_3D, grd) # which is the same as `s_dust_3D[iswet(grd)]`","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"We then write the generic boldsymbolG function, which is simply the constant dust source:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"G_dust(x, p) = s_dust","category":"page"},{"location":"tutorials/4_dustmodel/#Parameters","page":"A dust model","title":"Parameters","text":"","category":"section"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"We specify some initial values for the parameters and also include units.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"import AIBECS: @units, units\nimport AIBECS: @initial_value, initial_value\n@initial_value @units struct DustModelParameters{U} <: AbstractParameters{U}\n    w₀::U        | 0.1 | u\"km/yr\"\n    w′::U        | 0.1 | u\"km/yr/km\"\n    fsedremin::U | 5.0 | u\"percent\"\nend","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Finally, thanks to the initial values we provided, we can instantiate the parameter vector succintly as","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"p = DustModelParameters()","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"We generate the state function F and its Jacobian ∇ₓF,","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"F, ∇ₓF = state_function_and_Jacobian(T_dust, G_dust)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"generate the steady-state problem,","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"nb = sum(iswet(grd))\nx = ones(nb) # initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"and solve it","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"s = solve(prob, CTKAlg()).u","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Let's now run some vizualizations using the Plots.jl recipes.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"using Plots","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Let's have a look at a map of the dust per m² integrated over the whole water column:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"plotverticalintegral(s * u\"g/m^3\", grd, color=cgrad(:turbid, rev=true, scale=:exp))","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"compared to the original source","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"plt1 = plotverticalintegral(s_dust * u\"g/m^3/s\" .|> u\"mg/m^3/yr\", xlabel=\"\", ylabel=\"\", grd, color=cgrad(:starrynight, scale=:exp), title=\"Surface flux\")","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Huh? This is odd isn't it? What is happening? It seems that dust settles slowly enough to actually explore the ocean basins a little bit. This is of course dependent on our choice of model parameters.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Let's look at what is exported below 500 m and compare:","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"plt2 = plothorizontalslice(s * u\"g/m^3\" .* w(z,p) * u\"m/s\" .|> u\"mg/yr/m^2\", grd, depth=500u\"m\", color=cgrad(:starrynight, scale=:exp), xlabel=\"\", ylabel=\"\", title=\"Flux at 500m\")\nplot(plt1, plt2, layout=(2,1))","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"We can also take a look at the global mean profile (the horizontal average)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"plothorizontalmean(s * u\"g/m^3\" .|> u\"mg/m^3\", grd)","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"As you may see, it also seems that with this model, dust (here with a 1% fraction allowed to stay in the system when it reaches the seafloor) accumulates a little bit in the deepest boxes of the model grid.","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"Don't hesitate to play around with the parameters and see how things change! For example, impose a larger fraction that stays in the bottom or change other parameters via","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"p = DustModelParameters(w₀=0.1u\"km/yr\", w′=0.1u\"km/yr/km\", fsedremin=95.0u\"percent\")\nprob = SteadyStateProblem(F, ∇ₓF, x, p)\ns = solve(prob, CTKAlg()).u\nplotverticalintegral(s * u\"g/m^3\", grd, color=cgrad(:turbid, rev=true, scale=:exp))","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"And watch how all the dust accumulates in the deepest holes of the ocean basins!","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"","category":"page"},{"location":"tutorials/4_dustmodel/","page":"A dust model","title":"A dust model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/howtos/1_parameters.jl\"","category":"page"},{"location":"howtos/1_parameters/#parameters","page":"Parameters guide","title":"Parameters guide","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"(Image: ) (Image: )","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Here we will describe the AIBECS interface. This guide will take you through some examples of setting up model parameters.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"note: Note\nThe parameters features in AIBECS essentially come from other packages. These include Parameters.jl, FieldMetadata.jl, Flatten.jl, Unitful.jl.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"As usual, make sure you are using AIBECS","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"using AIBECS","category":"page"},{"location":"howtos/1_parameters/#Abstract-parameters-type","page":"Parameters guide","title":"Abstract parameters type","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"The AIBECS provides a set of features to create and use parameters. This features are implemented as functions that must be provided with a parameters type. But each set of parameters is different, and AIBECS cannot know beforehand what parameters you want to use. The AIBECS thus provides an abstract parameters type, called AbstractParameters, upon which all the AIBECS functionality is built. This is why when you create a set of parameters in AIBECS, you must declare it as a subtype of AbstractParameters. Here is an example.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"struct SimpleParams{T} <: AbstractParameters{T}\n    α::T\n    β::T\nend","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Once the type, which here simply defines the symbols (α and β), is constructed, we can instantiate a parameter variable.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = SimpleParams(1.0, 2.0)","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"As you can see, the AIBECS will display p as a table. This is because the show method converts p to a table (a DataFrame to be specific) under the hood:","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"AIBECS.table(p)","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"If you do not remember the order in which you created the parameters (α is first, β is second), AIBECS has got your back: keyword arguments are supported.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = SimpleParams(β = 2.0, α = 1.0)","category":"page"},{"location":"howtos/1_parameters/#Unpacking","page":"Parameters guide","title":"Unpacking","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Probably the most useful feature in AIBECS is the ability to elegantly unpack parameters, thanks to Parameters.jl.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"@unpack α, β = p\nα, β","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"unpacks the parameters on the left (α and β) from the parameter type p.","category":"page"},{"location":"howtos/1_parameters/#Units","page":"Parameters guide","title":"Units","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"One of the main features of parameters in AIBECS is that you can use units and let AIBECS do the conversions for you. Before you use units, though, you must import the @units and units functions from AIBECS. Here is an example.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @units, units\n@units struct UnitfulParams{T} <: AbstractParameters{T}\n    α::T | u\"m/s\"\n    β::T | u\"d\"\nend","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Cretaing an instance is just as easy","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(1.0, 2.0)","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"And in this case the parameters are shown with units. You can rely on AIBECS to convert units on the fly.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(3.0u\"km/hr\", 24.0u\"hr\")","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"And use keyword arguments","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParams(β = 24.0u\"hr\", α = 3.0u\"km/hr\")","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Unpacking parameters that have units first converts them to SI units.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"@unpack β = p\nβ","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"and β (which is equal to 1 day) here is expressed in seconds after being unpacked.","category":"page"},{"location":"howtos/1_parameters/#Initial-values","page":"Parameters guide","title":"Initial values","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Another useful feature is to set initial (or default) values. Again, you must import the functions for them to work properly","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @initial_value, initial_value\n@initial_value struct ParamsWithInitialValue{T} <: AbstractParameters{T}\n    α::T | 1.0\n    β::T | 2.0\nend","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"This is handy in many applications.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"You can instantiate p with the initial values as, well, its values.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = ParamsWithInitialValue()","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"You could also just set one parameter to a different value","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = ParamsWithInitialValue(β = 10.0)","category":"page"},{"location":"howtos/1_parameters/#Combining-initial-values-and-units","page":"Parameters guide","title":"Combining initial values and units","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"You can combine both features in parameters.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"@initial_value @units struct UnitfulParamsWithInitialValue{T} <: AbstractParameters{T}\n    α::T | 1.0 | u\"m/s\"\n    β::T | 2.0 | u\"d\"\nend","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"And instantiate p from just one parameter with its unit","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = UnitfulParamsWithInitialValue(β = 1.0u\"yr\")","category":"page"},{"location":"howtos/1_parameters/#Optimizable-parameters","page":"Parameters guide","title":"Optimizable parameters","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"import AIBECS: @flattenable, flattenable\n@flattenable struct OptimizableParams{T} <: AbstractParameters{T}\n    α::T | true\n    β::T | false\n    γ::T | true\nend","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Then the \"flattenable\" parameters will be the only ones to remain when converting OptimizableParams to a vector","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"p = OptimizableParams(1.0, 2.0, 3.0)\nv = vec(p)","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"The vec function uses the @unpack function in AIBECS, so that units are converted when vectorizing. Here is an example of that by first combining units and flattenable.","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"@initial_value @units @flattenable struct OptimizableParamsWithUnits{T} <: AbstractParameters{T}\n    α::T | 1.0 | u\"m/s\" | true\n    β::T | 2.0 | u\"d\"   | false\n    γ::T | 3.0 | u\"km\"  | true\nend\np = OptimizableParamsWithUnits()","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"And then vectorizing the parameters","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"vec(p)","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Note how γ (the third parameter, but the second flattenable one), is converted to meters.","category":"page"},{"location":"howtos/1_parameters/#Other-features","page":"Parameters guide","title":"Other features","text":"","category":"section"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"Coming soon!","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"","category":"page"},{"location":"howtos/1_parameters/","page":"Parameters guide","title":"Parameters guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"explanation/1_concept/#concept","page":"Concept","title":"Concept","text":"","category":"section"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"The AIBECS (pronounced like the cool ibex if you have a french accent) is a new software written in Julia to easily create some marine biogeochemistry models in just a few commands.","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"AIBECS is not just a single model. It's a system that allows you to create a global steady-state biogeochemistry model with just a few simple commands. Basically, you just need to tell AIBECS which ocean circulation to use (from simple toy models of just a few boxes to more complicated global models of the circulation), what elements you want to model/track, and how they are converted into other (the net local sources and sinks of your model). Once the model is set up, chose some parameter values and you can run simulations.","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"AIBECS relies on many tools from linear algebra to run simulations and perform optimizations really fast. AIBECS-generated models are described by a state function, denoted boldsymbolF, which defines how the concentrations of elements in the ocean evolve with time. In mathematical terms, this translates to a system of nonlinear differential equations with the generic form ","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"fracpartial boldsymbolxpartial t = boldsymbolF(boldsymbolx boldsymbolp)","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"where boldsymbolx is the state of the model (i.e., the concentrations of the tracers), and boldsymbolp are model parameters. With AIBECS, you can efficiently find the equilibrium of the system (AKA the steady-state). That is when the time-derivative is 0, so that","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"boldsymbolF(boldsymbolx boldsymbolp) = 0","category":"page"},{"location":"explanation/1_concept/","page":"Concept","title":"Concept","text":"and boldsymbolx does not change with time. Instead of simulating the evolution of boldsymbolx with time and waiting for the system to reach equilibrium — like most biogeochemistry models do — AIBECS uses linear algebra techniques, like Newton's method in multiple dimensions, or Krylov spaces, to implicitly solve for the steady-state solution, hence the \"algebraic\" and \"implicit\" names. This makes AIBECS much faster than the competition!","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"EditURL = \"https://github.com/JuliaOcean/AIBECS.jl/blob/master/docs/lit/tutorials/2_radiocarbon.jl\"","category":"page"},{"location":"tutorials/2_radiocarbon/#radiocarbon","page":"Radiocarbon","title":"Radiocarbon","text":"","category":"section"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"In this tutorial, we will simulate the radiocarbon age using the AIBECS by","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"defining the transport T(p) and the sources and sinks G(x,p),\ndefining the parameters p,\ngenerating the state function F(x,p) and solving the associated steady-state problem,\nand finally making a plot of our simulated radiocarbon age.","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nAlthough this tutorial is self-contained, it involves non-linearitiess and is slightly more complicated than the first tutorial for simulating the ideal age. (So do not hesitate to start with the ideal-age tutorial if you wish.)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"The tracer equation for radiocarbon is","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"big(partial_t + mathbfT big) boldsymbolR = fraclambdah (overlineboldsymbolR_mathsfatm - boldsymbolR) (boldsymbolz  h) - boldsymbolR  tau","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"where the first term on the right of the equal sign represents the air–sea gas exchange with a piston velocity λ over a depth h and the second term represents the radioactive decay of radiocarbon with timescale tau.","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nWe need not specify the value of the atmospheric radiocarbon concentration because it is not important for determining the age of a water parcel — only the relative concentration boldsymbolRoverlineboldsymbolR_mathsfatm matters.","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"We start by selecting the circulation for Radiocarbon. .) (And this time, we are using the OCCA matrix by Forget [1].)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"[1]: Forget, G., 2010: Mapping Ocean Observations in a Dynamical Framework: A 2004–06 Ocean Atlas. J. Phys. Oceanogr., 40, 1201–1221, doi:10.1175/2009JPO4043.1)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"using AIBECS\ngrd, T_OCCA = OCCA.load()\nT(p) = T_OCCA","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"The local sources and sinks are simply given by","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"function G(R,p)\n    @unpack λ, h, R̅atm, τ = p\n    return @. λ / h * (R̅atm - R) * (z ≤ h) - R / τ\nend","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"We can define z via","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"z = depthvec(grd)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"In this tutorial we will specify some units for the parameters. Such features must be imported to be used","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"import AIBECS: @units, units","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"We define the parameters using the dedicated API from the AIBECS, including keyword arguments and units this time","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"@units struct RadiocarbonParameters{U} <: AbstractParameters{U}\n    λ::U    | u\"m/yr\"\n    h::U    | u\"m\"\n    τ::U    | u\"yr\"\n    R̅atm::U | u\"M\"\nend","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"For the air–sea gas exchange, we use a constant piston velocity lambda of 50m / 10years. And for the radioactive decay we use a timescale tau of 5730/log(2) years.","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"p = RadiocarbonParameters(λ = 50u\"m\"/10u\"yr\",\n                          h = grd.δdepth[1],\n                          τ = 5730u\"yr\"/log(2),\n                          R̅atm = 42.0u\"nM\")","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"note: Note\nThe parameters are converted to SI units when unpacked. When you specify units for your parameters, you must either supply their values in that unit.","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"We generate the state function and its Jacobian, generate the corresponding steady-state problem, and solve it, via","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"F, ∇ₓF = state_function_and_Jacobian(T, G)\nx = zeros(length(z)) # an initial guess\nprob = SteadyStateProblem(F, ∇ₓF, x, p)\nR = solve(prob, CTKAlg()).u","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"This should take a few seconds on a laptop. Once the radiocarbon concentration is computed, we can convert it into the corresponding age in years, via","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"@unpack τ, R̅atm = p\nC14age = @. log(R̅atm / R) * τ * u\"s\" |> u\"yr\"","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"and plot it at 700 m using the horizontalslice Plots recipe","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"using Plots\nplothorizontalslice(C14age, grd, depth=700u\"m\", color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"look at a zonal average using the zonalaverage plot recipe","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"plotzonalaverage(C14age, grd; color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"or look at a meridional slice through the Atlantic at 30°W using the meridionalslice plot recipe","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"plotmeridionalslice(C14age, grd, lon=-30, color=:viridis)","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"","category":"page"},{"location":"tutorials/2_radiocarbon/","page":"Radiocarbon","title":"Radiocarbon","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"https://user-images.githubusercontent.com/4486578/60554111-8fc27400-9d79-11e9-9ca7-6d78ee89ea70.png\" alt=\"logo\" title=\"AIBECS_logo\" align=\"middle\" width=\"50%\"/>","category":"page"},{"location":"#AIBECS.jl","page":"Home","title":"AIBECS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Algebraic Implicit Biogeochemistry Elemental Cycling System","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you are using the AIBECS for the first time, you must add it to your Julia environment, by typing]add AIBECSat the REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is organized in 4 parts:","category":"page"},{"location":"#.-Tutorials","page":"Home","title":"1. Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to try AIBECS for the first time, this is where you should start.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The ideal age tutorial is a good place to start.   Generate a simple linear model of an idealized tracer in a few lines of code.\nThe radiocarbon tutorial is a little bit more involved, with some nonlinearities and more advanced use of AIBECS features and syntax.\nThe coupled PO₄–POP model tutorial couples 2 interacting tracers, dissolved phosphate and particulate organic phosphorus (POP).\nThe dust model tutorial simulates some fictitious metals being injected at the ocean–atmosphere interface and being reversibly scavenged.\nThe river discharge tutorial similarly simulates another fictitious radioactive tracer that is injected in the ocean by rivers and that decays away as time passes.","category":"page"},{"location":"#.-How-to-guides","page":"Home","title":"2. How-to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here you will find goal-oriented walk-through's.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Parameters guide\nPlotting basic things\nPlotting cruise/transects data\nEstimate fluxes\nHow to simulate, i.e., solve or timestep your model (coming soon!)\nHow to optimize parameters (coming soon!)\nHow to simulate sinking particles (coming soon!)","category":"page"},{"location":"#.-Explanation/discussion","page":"Home","title":"3. Explanation/discussion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here you will find more general discussions and explanations surrounding the AIBECS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The concept of the AIBECS\nTracer transport operators","category":"page"},{"location":"#.-Reference","page":"Home","title":"4. Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section contains the docstrings of (almost all) the functions available in AIBECS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe AIBECS is being developed primarily by Benoît Pasquier (postdoc with Seth John at the University of Southern California). If you use the AIBECS in your research, please cite it! Similarly, if you access data from within AIBECS (like the OCIM or OCCA ocean circulations) please cite them too.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package is in active development, so nothing is set in stone, and things may be broken sometimes. And if you have any suggestions or feature requests, do not hesitate to start an issue, or better even, submit a pull request!","category":"page"}]
}

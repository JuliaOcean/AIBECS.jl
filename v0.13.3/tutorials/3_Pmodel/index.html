<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A coupled PO₄–POP model · AIBECS.jl</title><meta name="title" content="A coupled PO₄–POP model · AIBECS.jl"/><meta property="og:title" content="A coupled PO₄–POP model · AIBECS.jl"/><meta property="twitter:title" content="A coupled PO₄–POP model · AIBECS.jl"/><meta name="description" content="Documentation for AIBECS.jl."/><meta property="og:description" content="Documentation for AIBECS.jl."/><meta property="twitter:description" content="Documentation for AIBECS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="AIBECS.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AIBECS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../1_ideal_age/">Ideal age</a></li><li><a class="tocitem" href="../2_radiocarbon/">Radiocarbon</a></li><li class="is-active"><a class="tocitem" href>A coupled PO₄–POP model</a></li><li><a class="tocitem" href="../4_dustmodel/">A dust model</a></li><li><a class="tocitem" href="../5_river_discharge/">River discharge</a></li><li><a class="tocitem" href="../6_groundwater_discharge/">Groundwater discharge</a></li></ul></li><li><span class="tocitem">How-to guides</span><ul><li><a class="tocitem" href="../../howtos/1_parameters/">Parameters guide</a></li><li><a class="tocitem" href="../../howtos/2_plot/">Plot basic things</a></li><li><a class="tocitem" href="../../howtos/3_cruiseplot/">Plot transect/cruise data</a></li><li><a class="tocitem" href="../../howtos/4_fluxes/">Estimate fluxes</a></li></ul></li><li><span class="tocitem">Explanation</span><ul><li><a class="tocitem" href="../../explanation/1_concept/">Concept</a></li><li><a class="tocitem" href="../../explanation/2_tracer_transport_operators/">Tracer transport</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/functions/">AIBECS interface (functions and types)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>A coupled PO₄–POP model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A coupled PO₄–POP model</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="P-model"><a class="docs-heading-anchor" href="#P-model">A coupled PO₄–POP model</a><a id="P-model-1"></a><a class="docs-heading-anchor-permalink" href="#P-model" title="Permalink"></a></h1><p>In this tutorial we will explicitly simulate 2 tracers whose distributions control and feed back on each other.</p><p>We consider a simple model for the cycling of phosphorus with 2 state variables consisting of phosphate (PO₄) AKA dissolved inorganic phosphorus (DIP) and particulate organic phosphorus (POP). The dissolved phases are transported by advection and diffusion whereas the particulate phase sinks rapidly down the water column without any appreciable transport by the circulation.</p><p>The governing equations that couple the 3D concentration fields of DIP and POP, denoted <span>$x_\mathsf{DIP}$</span> and <span>$x_\mathsf{POP}$</span>, respectively, are:</p><p class="math-container">\[\left[\frac{\partial}{\partial t} + \nabla \cdot (\boldsymbol{u} + \mathbf{K}\nabla )\right] x_\mathsf{DIP} = -U(x_\mathsf{DIP}) + R(x_\mathsf{POP}),\]</p><p>and</p><p class="math-container">\[\left[\frac{\partial}{\partial t} + \nabla \cdot \boldsymbol{w}\right] x_\mathsf{POP} = U(x_\mathsf{DIP}) - R(x_\mathsf{POP}).\]</p><p>The <span>$\nabla \cdot \left[ \boldsymbol{u} - \mathbf{K} \nabla \right]$</span> and <span>$\nabla \cdot \boldsymbol{w}$</span> operators represent the ocean circulation and the sinking of particles, respectively. (<a href="../../explanation/2_tracer_transport_operators/#tracer-transport-operators">Tracer transport operators are described in the documentation</a>.)</p><p>The function <span>$U$</span> represents the biological uptake of DIP by phytoplankton, which we model here as</p><p class="math-container">\[U(x_\mathsf{DIP}) = \frac{x_\mathsf{DIP}}{\tau_\mathsf{DIP}} \, \frac{x_\mathsf{DIP}}{x_\mathsf{DIP} + k} \, (z &lt; z_0),\]</p><p>with the timescale, <span>$\tau$</span>, the half-saturation rate <span>$k$</span>, and the depth <span>$z_0$</span> as parameters.</p><p>The function <span>$R$</span> defines the remineralization rate of POP, which converts POP back into DIP. For the remineralization, we simply use a linear rate constant, i.e.,</p><p class="math-container">\[R(x_\mathsf{POP}) = \frac{x_\mathsf{POP}}{\tau_\mathsf{POP}}.\]</p><p>We start by telling Julia we want to use the AIBECS and the OCIM0.1 circulation for DIP.</p><pre><code class="language-julia hljs">using AIBECS
grd, T_OCIM = OCIM0.load()
T_DIP(p) = T_OCIM</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">T_DIP (generic function with 1 method)</code></pre><p>For the sinking of particles, we use the <code>transportoperator</code> function</p><pre><code class="language-julia hljs">T_POP(p) = transportoperator(grd, z -&gt; w(z,p))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">T_POP (generic function with 1 method)</code></pre><p>for which we need to define the sinking speed <code>w(z,p)</code> as a function of depth <code>z</code> and of the parameters <code>p</code>. Following the assumption that <span>$w(z) = w_0 + w&#39; z$</span> increases linearly with depth, we write it as</p><pre><code class="language-julia hljs">function w(z,p)
    @unpack w₀, w′ = p
    return @. w₀ + w′ * z
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">w (generic function with 1 method)</code></pre><h5 id="Uptake-(DIP-POP)"><a class="docs-heading-anchor" href="#Uptake-(DIP-POP)">Uptake (DIP → POP)</a><a id="Uptake-(DIP-POP)-1"></a><a class="docs-heading-anchor-permalink" href="#Uptake-(DIP-POP)" title="Permalink"></a></h5><p>For the uptake, <span>$U$</span>, we write</p><pre><code class="language-julia hljs">z = depthvec(grd)
function U(x,p)
    @unpack τ_DIP, k, z₀ = p
    return @. x/τ_DIP * x/(x+k) * (z≤z₀) * (x≥0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">U (generic function with 1 method)</code></pre><p>where we have &quot;unpacked&quot; the parameters to make the code clearer and as close to the mathematical equation as possible. (Note we have also added a constraint that <code>x</code> must be positive for uptake to happen.)</p><h5 id="Remineralization-(POP-DIP)"><a class="docs-heading-anchor" href="#Remineralization-(POP-DIP)">Remineralization (POP → DIP)</a><a id="Remineralization-(POP-DIP)-1"></a><a class="docs-heading-anchor-permalink" href="#Remineralization-(POP-DIP)" title="Permalink"></a></h5><p>For the remineralization, <span>$R$</span>, we write</p><pre><code class="language-julia hljs">function R(x,p)
    @unpack τ_POP = p
    return x / τ_POP
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">R (generic function with 1 method)</code></pre><h5 id="Net-sources-and-sinks"><a class="docs-heading-anchor" href="#Net-sources-and-sinks">Net sources and sinks</a><a id="Net-sources-and-sinks-1"></a><a class="docs-heading-anchor-permalink" href="#Net-sources-and-sinks" title="Permalink"></a></h5><p>We lump the sources and sinks into <code>G</code> functions for DIP and POP.</p><pre><code class="language-julia hljs">function G_DIP(DIP, POP, p)
    @unpack DIP_geo, τ_geo = p
    return @. -$U(DIP,p) + $R(POP,p) + (DIP_geo - DIP) / τ_geo
end
function G_POP(DIP, POP, p)
    @unpack τ_geo = p
    return @. $U(DIP,p) - $R(POP,p) - POP / τ_geo
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">G_POP (generic function with 1 method)</code></pre><p>where we have imposed a slow restoring of DIP to the global mean <code>DIP_geo</code> to prescribe the global mean concentration. (The <code>$</code> signs in front of <code>U</code> and <code>R</code> protect them from the broadcast macro <code>@.</code>)</p><p>We now define and build the parameters.</p><p>In this tutorial we will specify some initial values for the parameters and also include units.</p><pre><code class="language-julia hljs">import AIBECS: @units, units
import AIBECS: @initial_value, initial_value
using Unitful: m, d, s, yr, Myr, mol, mmol, μmol, μM
@initial_value @units struct PmodelParameters{U} &lt;: AbstractParameters{U}
    w₀::U       |  0.64 | m/d
    w′::U       |  0.13 | m/d/m
    τ_DIP::U    | 230.0 | d
    k::U        |  6.62 | μmol/m^3
    z₀::U       |  80.0 | m
    τ_POP::U    |   5.0 | d
    τ_geo::U    |   1.0 | Myr
    DIP_geo::U  |  2.12 | mmol/m^3
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initial_value (generic function with 24 methods)</code></pre><p>Finally, thanks to the initial values we provided, we can instantiate the parameter vector succintly as</p><pre><code class="language-julia hljs">p = PmodelParameters()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1"> Row │ Symbol   Value    Initial value  Unit
     │<span class="sgr90"> Symbol   Float64  Float64        FreeUnit…
─────┼────────────────────────────────────────────
   1 │ w₀          0.64           0.64  m d⁻¹
   2 │ w′          0.13           0.13  d⁻¹
   3 │ τ_DIP     230.0          230.0   d
   4 │ k           6.62           6.62  μmol m⁻³
   5 │ z₀         80.0           80.0   m
   6 │ τ_POP       5.0            5.0   d
   7 │ τ_geo       1.0            1.0   Myr
   8 │ DIP_geo     2.12           2.12  mmol m⁻³</span></span></code></pre><p>We generate the state function <code>F</code>,</p><pre><code class="language-julia hljs">nb = sum(iswet(grd))
F = AIBECSFunction((T_DIP, T_POP), (G_DIP, G_POP), nb)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(::SciMLBase.ODEFunction{false, SciMLBase.FullSpecialize, AIBECS.var&quot;#f#58&quot;{Tuple{typeof(Main.T_DIP), typeof(Main.T_POP)}, UnitRange{Int64}, AIBECS.var&quot;#G#56&quot;{Tuple{typeof(Main.G_DIP), typeof(Main.G_POP)}, AIBECS.var&quot;#tracers#54&quot;{Int64, Int64}}, AIBECS.var&quot;#tracer#55&quot;{Int64, Int64}}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, AIBECS.var&quot;#jac#63&quot;{AIBECS.var&quot;#T#60&quot;{Tuple{typeof(Main.T_DIP), typeof(Main.T_POP)}, Int64, UnitRange{Int64}}, AIBECS.var&quot;#∇ₓG#59&quot;{Tuple{typeof(Main.G_DIP), typeof(Main.G_POP)}, Int64, Int64}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}) (generic function with 1 method)</code></pre><p>generate the steady-state problem,</p><pre><code class="language-julia hljs">@unpack DIP_geo = p
x = DIP_geo * ones(2nb) # initial guess
prob = SteadyStateProblem(F, x, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">SteadyStateProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">false</span>
u0: 382338-element Vector{Float64}:
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 ⋮
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004
 0.0021200000000000004</code></pre><p>and solve it</p><pre><code class="language-julia hljs">sol = solve(prob, CTKAlg()).u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">382338-element Vector{Float64}:
 0.0020967060231664295
 0.0021333454639532027
 0.0018399997020561354
 0.0017256341824069535
 0.001612328585777842
 0.0015535540266685076
 0.001458541565317635
 0.001570008107294452
 0.001457342544838417
 0.00135850268497681
 ⋮
 2.7883468616763368e-9
 1.6701226349887806e-9
 1.8293710129060015e-9
 2.873136469222496e-9
 2.993647120876417e-9
 2.8588624377785625e-9
 3.2379918118282254e-9
 3.0900967665459405e-9
 3.1845337501702697e-9</code></pre><p>We can look at different the DIP and POP fields using the Plots.jl recipes.</p><pre><code class="language-julia hljs">DIP, POP = state_to_tracers(sol, grd) # unpack tracers</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.0020967060231664295, 0.0021333454639532027, 0.0018399997020561354, 0.0017256341824069535, 0.001612328585777842, 0.0015535540266685076, 0.001458541565317635, 0.001570008107294452, 0.001457342544838417, 0.00135850268497681  …  0.001411275166907556, 0.001412264306571928, 0.0013911523315427185, 0.0013911433495659214, 0.0021377405632125503, 0.0021393993335517133, 0.002135737129869365, 0.0021249929534287804, 0.0021344756362701237, 0.0021379362067694492], [2.6134960067708514e-5, 2.6593099800802548e-5, 2.292510803375331e-5, 2.1495086727744334e-5, 2.007832138108026e-5, 1.934340962415626e-5, 1.8155384587571548e-5, 1.9549149860286034e-5, 1.8140392190430782e-5, 1.6904513204783926e-5  …  3.0408296778339733e-9, 2.7883468616763368e-9, 1.6701226349887806e-9, 1.8293710129060015e-9, 2.873136469222496e-9, 2.993647120876417e-9, 2.8588624377785625e-9, 3.2379918118282254e-9, 3.0900967665459405e-9, 3.1845337501702697e-9])</code></pre><p>First, let&#39;s look at the mean profile</p><pre><code class="language-julia hljs">using Plots
plothorizontalmean(DIP * (mol/m^3) .|&gt; μM, grd)</code></pre><img src="0856ae8b.svg" alt="Example block output"/><p>We can plot the concentration of DIP at a given depth via, e.g.,</p><pre><code class="language-julia hljs">plothorizontalslice(DIP * (mol/m^3) .|&gt; μM, grd, depth=1000m, color=:viridis)</code></pre><img src="e1122fbc.svg" alt="Example block output"/><p>Or have a look at a map of the uptake at the surface</p><pre><code class="language-julia hljs">plotverticalintegral(U(DIP,p) * (mol/m^3/s) .|&gt; mmol/yr/m^3, grd, color=:algae)</code></pre><img src="40882b42.svg" alt="Example block output"/><p>Or look at what is exported below 500 m</p><pre><code class="language-julia hljs">plothorizontalslice(POP .* w(z,p) * (mol/m^3*m/s) .|&gt; mmol/yr/m^2, grd, depth=500m, color=:inferno, rev=true)</code></pre><img src="4fa9a9fd.svg" alt="Example block output"/><p>Now let&#39;s make our model a little fancier and use a fine topographic map to refine the remineralization profile. For this, we will use the ETOPO dataset, which can be downloaded by AIBECS via</p><pre><code class="language-julia hljs">f_topo = ETOPO.fractiontopo(grd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">191169-element Vector{Float64}:
 0.0006887052341597796
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.9904166666666666
 0.9914583333333333
 0.9657638888888889
 0.9586805555555555
 0.9751388888888889
 0.9947222222222222
 0.9328472222222223
 0.9486111111111111
 0.9800694444444444</code></pre><p><code>f_topo</code> is the fraction of sediments located in each wet box of the <code>grd</code> grid. We can use it to redefine the transport operator for sinking particles to take into consideration the subgrid topography, such that the fine-resolution sediments intercept settling POP.</p><pre><code class="language-julia hljs">T_POP2(p) = transportoperator(grd, z -&gt; w(z,p); frac_seafloor=f_topo)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">T_POP2 (generic function with 1 method)</code></pre><p>With this new vertical transport for POP, we can recreate our problem, solve it again</p><pre><code class="language-julia hljs">F2 = AIBECSFunction((T_DIP, T_POP2), (G_DIP, G_POP), nb)
prob2 = SteadyStateProblem(F2, x, p)
sol2 = solve(prob2, CTKAlg()).u
DIP2, POP2 = state_to_tracers(sol2, grd) # unpack tracers</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.002098085071985876, 0.0021343221222590372, 0.001840983313044677, 0.001726670590169758, 0.0016137061456333046, 0.0015554917832502086, 0.0014607122946576803, 0.0015728691982204667, 0.0014603298577997833, 0.0013625583518128337  …  0.0014213554906768006, 0.0014223553341716668, 0.001401365142005268, 0.001401359910709824, 0.0021407469293816704, 0.002142403108241433, 0.0021387585449112196, 0.0021280771897256535, 0.002137500584097961, 0.0021409435430922575], [2.615985726077029e-5, 2.66053119427593e-5, 2.2937407071766355e-5, 2.150804591211601e-5, 2.009554627567894e-5, 1.9367639141425456e-5, 1.818252710802236e-5, 1.958492467288954e-5, 1.8177745166624564e-5, 1.6955224585933824e-5  …  3.1092058441255798e-9, 2.8716550526604888e-9, 1.8040447193459132e-9, 1.9772526509285164e-9, 2.937879236394193e-9, 3.0701301969675845e-9, 2.9462721482362614e-9, 3.2997240879145508e-9, 3.15904173541064e-9, 3.266028827607643e-9])</code></pre><p>and check the difference</p><pre><code class="language-julia hljs">plotzonalaverage((DIP2 - DIP) ./ DIP .|&gt; u&quot;percent&quot;, grd, color=:balance, clim=(-5,5))</code></pre><img src="8d04fb49.svg" alt="Example block output"/><p>This zonal average shows how much DIP is redistributed as it is prevented from sinking out of the surface layers with the new subgrid parameterization.</p><p>Let&#39;s look at the vertical average.</p><pre><code class="language-julia hljs">plotverticalaverage((DIP2 - DIP) ./ DIP .|&gt; u&quot;percent&quot;, grd, color=:balance, clim=(-10,10))</code></pre><img src="4a6b5903.svg" alt="Example block output"/><p>This shows minor changes on the order of 1%, on the global scale, except along the coasts, which retain much more DIP with the subgrid topography.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../2_radiocarbon/">« Radiocarbon</a><a class="docs-footer-nextpage" href="../4_dustmodel/">A dust model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 23 May 2024 04:09">Thursday 23 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
